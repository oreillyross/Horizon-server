/**
 * This file was automatically generated by nexus-prisma@0.3.5
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
  interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
  objectTypes: {
    fields: {
      Query: QueryObject
      User: UserObject
      UserConnection: UserConnectionObject
      PageInfo: PageInfoObject
      UserEdge: UserEdgeObject
      AggregateUser: AggregateUserObject
      Event: EventObject
      Indication: IndicationObject
      Indicator: IndicatorObject
      Keyword: KeywordObject
      Scenario: ScenarioObject
      Strength: StrengthObject
      Category: CategoryObject
      EventConnection: EventConnectionObject
      EventEdge: EventEdgeObject
      AggregateEvent: AggregateEventObject
      CategoryConnection: CategoryConnectionObject
      CategoryEdge: CategoryEdgeObject
      AggregateCategory: AggregateCategoryObject
      KeywordConnection: KeywordConnectionObject
      KeywordEdge: KeywordEdgeObject
      AggregateKeyword: AggregateKeywordObject
      ScenarioConnection: ScenarioConnectionObject
      ScenarioEdge: ScenarioEdgeObject
      AggregateScenario: AggregateScenarioObject
      IndicatorConnection: IndicatorConnectionObject
      IndicatorEdge: IndicatorEdgeObject
      AggregateIndicator: AggregateIndicatorObject
      IndicationConnection: IndicationConnectionObject
      IndicationEdge: IndicationEdgeObject
      AggregateIndication: AggregateIndicationObject
      StrengthConnection: StrengthConnectionObject
      StrengthEdge: StrengthEdgeObject
      AggregateStrength: AggregateStrengthObject
      Mutation: MutationObject
      BatchPayload: BatchPayloadObject
      Subscription: SubscriptionObject
      UserSubscriptionPayload: UserSubscriptionPayloadObject
      UserPreviousValues: UserPreviousValuesObject
      EventSubscriptionPayload: EventSubscriptionPayloadObject
      EventPreviousValues: EventPreviousValuesObject
      CategorySubscriptionPayload: CategorySubscriptionPayloadObject
      CategoryPreviousValues: CategoryPreviousValuesObject
      KeywordSubscriptionPayload: KeywordSubscriptionPayloadObject
      KeywordPreviousValues: KeywordPreviousValuesObject
      ScenarioSubscriptionPayload: ScenarioSubscriptionPayloadObject
      ScenarioPreviousValues: ScenarioPreviousValuesObject
      IndicatorSubscriptionPayload: IndicatorSubscriptionPayloadObject
      IndicatorPreviousValues: IndicatorPreviousValuesObject
      IndicationSubscriptionPayload: IndicationSubscriptionPayloadObject
      IndicationPreviousValues: IndicationPreviousValuesObject
      StrengthSubscriptionPayload: StrengthSubscriptionPayloadObject
      StrengthPreviousValues: StrengthPreviousValuesObject
    }
    fieldsDetails: {
      Query: QueryFieldDetails
      User: UserFieldDetails
      UserConnection: UserConnectionFieldDetails
      PageInfo: PageInfoFieldDetails
      UserEdge: UserEdgeFieldDetails
      AggregateUser: AggregateUserFieldDetails
      Event: EventFieldDetails
      Indication: IndicationFieldDetails
      Indicator: IndicatorFieldDetails
      Keyword: KeywordFieldDetails
      Scenario: ScenarioFieldDetails
      Strength: StrengthFieldDetails
      Category: CategoryFieldDetails
      EventConnection: EventConnectionFieldDetails
      EventEdge: EventEdgeFieldDetails
      AggregateEvent: AggregateEventFieldDetails
      CategoryConnection: CategoryConnectionFieldDetails
      CategoryEdge: CategoryEdgeFieldDetails
      AggregateCategory: AggregateCategoryFieldDetails
      KeywordConnection: KeywordConnectionFieldDetails
      KeywordEdge: KeywordEdgeFieldDetails
      AggregateKeyword: AggregateKeywordFieldDetails
      ScenarioConnection: ScenarioConnectionFieldDetails
      ScenarioEdge: ScenarioEdgeFieldDetails
      AggregateScenario: AggregateScenarioFieldDetails
      IndicatorConnection: IndicatorConnectionFieldDetails
      IndicatorEdge: IndicatorEdgeFieldDetails
      AggregateIndicator: AggregateIndicatorFieldDetails
      IndicationConnection: IndicationConnectionFieldDetails
      IndicationEdge: IndicationEdgeFieldDetails
      AggregateIndication: AggregateIndicationFieldDetails
      StrengthConnection: StrengthConnectionFieldDetails
      StrengthEdge: StrengthEdgeFieldDetails
      AggregateStrength: AggregateStrengthFieldDetails
      Mutation: MutationFieldDetails
      BatchPayload: BatchPayloadFieldDetails
      Subscription: SubscriptionFieldDetails
      UserSubscriptionPayload: UserSubscriptionPayloadFieldDetails
      UserPreviousValues: UserPreviousValuesFieldDetails
      EventSubscriptionPayload: EventSubscriptionPayloadFieldDetails
      EventPreviousValues: EventPreviousValuesFieldDetails
      CategorySubscriptionPayload: CategorySubscriptionPayloadFieldDetails
      CategoryPreviousValues: CategoryPreviousValuesFieldDetails
      KeywordSubscriptionPayload: KeywordSubscriptionPayloadFieldDetails
      KeywordPreviousValues: KeywordPreviousValuesFieldDetails
      ScenarioSubscriptionPayload: ScenarioSubscriptionPayloadFieldDetails
      ScenarioPreviousValues: ScenarioPreviousValuesFieldDetails
      IndicatorSubscriptionPayload: IndicatorSubscriptionPayloadFieldDetails
      IndicatorPreviousValues: IndicatorPreviousValuesFieldDetails
      IndicationSubscriptionPayload: IndicationSubscriptionPayloadFieldDetails
      IndicationPreviousValues: IndicationPreviousValuesFieldDetails
      StrengthSubscriptionPayload: StrengthSubscriptionPayloadFieldDetails
      StrengthPreviousValues: StrengthPreviousValuesFieldDetails
    }
  }
  inputTypes: {
    fields: {
      UserWhereUniqueInput: UserWhereUniqueInputInputObject
      UserWhereInput: UserWhereInputInputObject
      EventWhereUniqueInput: EventWhereUniqueInputInputObject
      IndicationWhereInput: IndicationWhereInputInputObject
      IndicatorWhereInput: IndicatorWhereInputInputObject
      KeywordWhereInput: KeywordWhereInputInputObject
      ScenarioWhereInput: ScenarioWhereInputInputObject
      EventWhereInput: EventWhereInputInputObject
      CategoryWhereInput: CategoryWhereInputInputObject
      StrengthWhereInput: StrengthWhereInputInputObject
      CategoryWhereUniqueInput: CategoryWhereUniqueInputInputObject
      KeywordWhereUniqueInput: KeywordWhereUniqueInputInputObject
      ScenarioWhereUniqueInput: ScenarioWhereUniqueInputInputObject
      IndicatorWhereUniqueInput: IndicatorWhereUniqueInputInputObject
      IndicationWhereUniqueInput: IndicationWhereUniqueInputInputObject
      StrengthWhereUniqueInput: StrengthWhereUniqueInputInputObject
      UserCreateInput: UserCreateInputInputObject
      UserUpdateInput: UserUpdateInputInputObject
      UserUpdateManyMutationInput: UserUpdateManyMutationInputInputObject
      EventCreateInput: EventCreateInputInputObject
      IndicationCreateManyWithoutEventInput: IndicationCreateManyWithoutEventInputInputObject
      IndicationCreateWithoutEventInput: IndicationCreateWithoutEventInputInputObject
      IndicatorCreateOneInput: IndicatorCreateOneInputInputObject
      IndicatorCreateInput: IndicatorCreateInputInputObject
      KeywordCreateManyWithoutIndicatorsInput: KeywordCreateManyWithoutIndicatorsInputInputObject
      KeywordCreateWithoutIndicatorsInput: KeywordCreateWithoutIndicatorsInputInputObject
      ScenarioCreateManyWithoutIndicatorsInput: ScenarioCreateManyWithoutIndicatorsInputInputObject
      ScenarioCreateWithoutIndicatorsInput: ScenarioCreateWithoutIndicatorsInputInputObject
      StrengthCreateOneInput: StrengthCreateOneInputInputObject
      StrengthCreateInput: StrengthCreateInputInputObject
      CategoryCreateManyWithoutEventsInput: CategoryCreateManyWithoutEventsInputInputObject
      CategoryCreateWithoutEventsInput: CategoryCreateWithoutEventsInputInputObject
      EventUpdateInput: EventUpdateInputInputObject
      IndicationUpdateManyWithoutEventInput: IndicationUpdateManyWithoutEventInputInputObject
      IndicationUpdateWithWhereUniqueWithoutEventInput: IndicationUpdateWithWhereUniqueWithoutEventInputInputObject
      IndicationUpdateWithoutEventDataInput: IndicationUpdateWithoutEventDataInputInputObject
      IndicatorUpdateOneRequiredInput: IndicatorUpdateOneRequiredInputInputObject
      IndicatorUpdateDataInput: IndicatorUpdateDataInputInputObject
      KeywordUpdateManyWithoutIndicatorsInput: KeywordUpdateManyWithoutIndicatorsInputInputObject
      KeywordUpdateWithWhereUniqueWithoutIndicatorsInput: KeywordUpdateWithWhereUniqueWithoutIndicatorsInputInputObject
      KeywordUpdateWithoutIndicatorsDataInput: KeywordUpdateWithoutIndicatorsDataInputInputObject
      KeywordUpsertWithWhereUniqueWithoutIndicatorsInput: KeywordUpsertWithWhereUniqueWithoutIndicatorsInputInputObject
      KeywordScalarWhereInput: KeywordScalarWhereInputInputObject
      KeywordUpdateManyWithWhereNestedInput: KeywordUpdateManyWithWhereNestedInputInputObject
      KeywordUpdateManyDataInput: KeywordUpdateManyDataInputInputObject
      ScenarioUpdateManyWithoutIndicatorsInput: ScenarioUpdateManyWithoutIndicatorsInputInputObject
      ScenarioUpdateWithWhereUniqueWithoutIndicatorsInput: ScenarioUpdateWithWhereUniqueWithoutIndicatorsInputInputObject
      ScenarioUpdateWithoutIndicatorsDataInput: ScenarioUpdateWithoutIndicatorsDataInputInputObject
      ScenarioUpsertWithWhereUniqueWithoutIndicatorsInput: ScenarioUpsertWithWhereUniqueWithoutIndicatorsInputInputObject
      ScenarioScalarWhereInput: ScenarioScalarWhereInputInputObject
      ScenarioUpdateManyWithWhereNestedInput: ScenarioUpdateManyWithWhereNestedInputInputObject
      ScenarioUpdateManyDataInput: ScenarioUpdateManyDataInputInputObject
      IndicatorUpsertNestedInput: IndicatorUpsertNestedInputInputObject
      StrengthUpdateOneRequiredInput: StrengthUpdateOneRequiredInputInputObject
      StrengthUpdateDataInput: StrengthUpdateDataInputInputObject
      StrengthUpsertNestedInput: StrengthUpsertNestedInputInputObject
      IndicationUpsertWithWhereUniqueWithoutEventInput: IndicationUpsertWithWhereUniqueWithoutEventInputInputObject
      IndicationScalarWhereInput: IndicationScalarWhereInputInputObject
      CategoryUpdateManyWithoutEventsInput: CategoryUpdateManyWithoutEventsInputInputObject
      CategoryUpdateWithWhereUniqueWithoutEventsInput: CategoryUpdateWithWhereUniqueWithoutEventsInputInputObject
      CategoryUpdateWithoutEventsDataInput: CategoryUpdateWithoutEventsDataInputInputObject
      CategoryUpsertWithWhereUniqueWithoutEventsInput: CategoryUpsertWithWhereUniqueWithoutEventsInputInputObject
      CategoryScalarWhereInput: CategoryScalarWhereInputInputObject
      CategoryUpdateManyWithWhereNestedInput: CategoryUpdateManyWithWhereNestedInputInputObject
      CategoryUpdateManyDataInput: CategoryUpdateManyDataInputInputObject
      EventUpdateManyMutationInput: EventUpdateManyMutationInputInputObject
      CategoryCreateInput: CategoryCreateInputInputObject
      EventCreateManyWithoutCategoriesInput: EventCreateManyWithoutCategoriesInputInputObject
      EventCreateWithoutCategoriesInput: EventCreateWithoutCategoriesInputInputObject
      CategoryUpdateInput: CategoryUpdateInputInputObject
      EventUpdateManyWithoutCategoriesInput: EventUpdateManyWithoutCategoriesInputInputObject
      EventUpdateWithWhereUniqueWithoutCategoriesInput: EventUpdateWithWhereUniqueWithoutCategoriesInputInputObject
      EventUpdateWithoutCategoriesDataInput: EventUpdateWithoutCategoriesDataInputInputObject
      EventUpsertWithWhereUniqueWithoutCategoriesInput: EventUpsertWithWhereUniqueWithoutCategoriesInputInputObject
      EventScalarWhereInput: EventScalarWhereInputInputObject
      EventUpdateManyWithWhereNestedInput: EventUpdateManyWithWhereNestedInputInputObject
      EventUpdateManyDataInput: EventUpdateManyDataInputInputObject
      CategoryUpdateManyMutationInput: CategoryUpdateManyMutationInputInputObject
      KeywordCreateInput: KeywordCreateInputInputObject
      IndicatorCreateManyWithoutKeywordsInput: IndicatorCreateManyWithoutKeywordsInputInputObject
      IndicatorCreateWithoutKeywordsInput: IndicatorCreateWithoutKeywordsInputInputObject
      KeywordUpdateInput: KeywordUpdateInputInputObject
      IndicatorUpdateManyWithoutKeywordsInput: IndicatorUpdateManyWithoutKeywordsInputInputObject
      IndicatorUpdateWithWhereUniqueWithoutKeywordsInput: IndicatorUpdateWithWhereUniqueWithoutKeywordsInputInputObject
      IndicatorUpdateWithoutKeywordsDataInput: IndicatorUpdateWithoutKeywordsDataInputInputObject
      IndicatorUpsertWithWhereUniqueWithoutKeywordsInput: IndicatorUpsertWithWhereUniqueWithoutKeywordsInputInputObject
      IndicatorScalarWhereInput: IndicatorScalarWhereInputInputObject
      IndicatorUpdateManyWithWhereNestedInput: IndicatorUpdateManyWithWhereNestedInputInputObject
      IndicatorUpdateManyDataInput: IndicatorUpdateManyDataInputInputObject
      KeywordUpdateManyMutationInput: KeywordUpdateManyMutationInputInputObject
      ScenarioCreateInput: ScenarioCreateInputInputObject
      IndicatorCreateManyWithoutScenariosInput: IndicatorCreateManyWithoutScenariosInputInputObject
      IndicatorCreateWithoutScenariosInput: IndicatorCreateWithoutScenariosInputInputObject
      ScenarioUpdateInput: ScenarioUpdateInputInputObject
      IndicatorUpdateManyWithoutScenariosInput: IndicatorUpdateManyWithoutScenariosInputInputObject
      IndicatorUpdateWithWhereUniqueWithoutScenariosInput: IndicatorUpdateWithWhereUniqueWithoutScenariosInputInputObject
      IndicatorUpdateWithoutScenariosDataInput: IndicatorUpdateWithoutScenariosDataInputInputObject
      IndicatorUpsertWithWhereUniqueWithoutScenariosInput: IndicatorUpsertWithWhereUniqueWithoutScenariosInputInputObject
      ScenarioUpdateManyMutationInput: ScenarioUpdateManyMutationInputInputObject
      IndicatorUpdateInput: IndicatorUpdateInputInputObject
      IndicatorUpdateManyMutationInput: IndicatorUpdateManyMutationInputInputObject
      IndicationCreateInput: IndicationCreateInputInputObject
      EventCreateOneWithoutIndicationsInput: EventCreateOneWithoutIndicationsInputInputObject
      EventCreateWithoutIndicationsInput: EventCreateWithoutIndicationsInputInputObject
      IndicationUpdateInput: IndicationUpdateInputInputObject
      EventUpdateOneRequiredWithoutIndicationsInput: EventUpdateOneRequiredWithoutIndicationsInputInputObject
      EventUpdateWithoutIndicationsDataInput: EventUpdateWithoutIndicationsDataInputInputObject
      EventUpsertWithoutIndicationsInput: EventUpsertWithoutIndicationsInputInputObject
      StrengthUpdateInput: StrengthUpdateInputInputObject
      StrengthUpdateManyMutationInput: StrengthUpdateManyMutationInputInputObject
      UserSubscriptionWhereInput: UserSubscriptionWhereInputInputObject
      EventSubscriptionWhereInput: EventSubscriptionWhereInputInputObject
      CategorySubscriptionWhereInput: CategorySubscriptionWhereInputInputObject
      KeywordSubscriptionWhereInput: KeywordSubscriptionWhereInputInputObject
      ScenarioSubscriptionWhereInput: ScenarioSubscriptionWhereInputInputObject
      IndicatorSubscriptionWhereInput: IndicatorSubscriptionWhereInputInputObject
      IndicationSubscriptionWhereInput: IndicationSubscriptionWhereInputInputObject
      StrengthSubscriptionWhereInput: StrengthSubscriptionWhereInputInputObject
    }
  }
  enumTypes: {
    UserOrderByInput: UserOrderByInputValues,
    IndicationOrderByInput: IndicationOrderByInputValues,
    KeywordOrderByInput: KeywordOrderByInputValues,
    IndicatorOrderByInput: IndicatorOrderByInputValues,
    ScenarioOrderByInput: ScenarioOrderByInputValues,
    CategoryOrderByInput: CategoryOrderByInputValues,
    EventOrderByInput: EventOrderByInputValues,
    StrengthOrderByInput: StrengthOrderByInputValues,
    MutationType: MutationTypeValues,
  }
}

// Types for Query

type QueryObject =
  | QueryFields
  | { name: 'user', args?: QueryUserArgs[] | false, alias?: string  } 
  | { name: 'users', args?: QueryUsersArgs[] | false, alias?: string  } 
  | { name: 'usersConnection', args?: QueryUsersConnectionArgs[] | false, alias?: string  } 
  | { name: 'event', args?: QueryEventArgs[] | false, alias?: string  } 
  | { name: 'events', args?: QueryEventsArgs[] | false, alias?: string  } 
  | { name: 'eventsConnection', args?: QueryEventsConnectionArgs[] | false, alias?: string  } 
  | { name: 'category', args?: QueryCategoryArgs[] | false, alias?: string  } 
  | { name: 'categories', args?: QueryCategoriesArgs[] | false, alias?: string  } 
  | { name: 'categoriesConnection', args?: QueryCategoriesConnectionArgs[] | false, alias?: string  } 
  | { name: 'keyword', args?: QueryKeywordArgs[] | false, alias?: string  } 
  | { name: 'keywords', args?: QueryKeywordsArgs[] | false, alias?: string  } 
  | { name: 'keywordsConnection', args?: QueryKeywordsConnectionArgs[] | false, alias?: string  } 
  | { name: 'scenario', args?: QueryScenarioArgs[] | false, alias?: string  } 
  | { name: 'scenarios', args?: QueryScenariosArgs[] | false, alias?: string  } 
  | { name: 'scenariosConnection', args?: QueryScenariosConnectionArgs[] | false, alias?: string  } 
  | { name: 'indicator', args?: QueryIndicatorArgs[] | false, alias?: string  } 
  | { name: 'indicators', args?: QueryIndicatorsArgs[] | false, alias?: string  } 
  | { name: 'indicatorsConnection', args?: QueryIndicatorsConnectionArgs[] | false, alias?: string  } 
  | { name: 'indication', args?: QueryIndicationArgs[] | false, alias?: string  } 
  | { name: 'indications', args?: QueryIndicationsArgs[] | false, alias?: string  } 
  | { name: 'indicationsConnection', args?: QueryIndicationsConnectionArgs[] | false, alias?: string  } 
  | { name: 'strength', args?: QueryStrengthArgs[] | false, alias?: string  } 
  | { name: 'strengths', args?: QueryStrengthsArgs[] | false, alias?: string  } 
  | { name: 'strengthsConnection', args?: QueryStrengthsConnectionArgs[] | false, alias?: string  } 

type QueryFields =
  | 'user'
  | 'users'
  | 'usersConnection'
  | 'event'
  | 'events'
  | 'eventsConnection'
  | 'category'
  | 'categories'
  | 'categoriesConnection'
  | 'keyword'
  | 'keywords'
  | 'keywordsConnection'
  | 'scenario'
  | 'scenarios'
  | 'scenariosConnection'
  | 'indicator'
  | 'indicators'
  | 'indicatorsConnection'
  | 'indication'
  | 'indications'
  | 'indicationsConnection'
  | 'strength'
  | 'strengths'
  | 'strengthsConnection'


type QueryUserArgs =
  | 'where'
type QueryUsersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryUsersConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryEventArgs =
  | 'where'
type QueryEventsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryEventsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCategoryArgs =
  | 'where'
type QueryCategoriesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCategoriesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryKeywordArgs =
  | 'where'
type QueryKeywordsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryKeywordsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryScenarioArgs =
  | 'where'
type QueryScenariosArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryScenariosConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryIndicatorArgs =
  | 'where'
type QueryIndicatorsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryIndicatorsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryIndicationArgs =
  | 'where'
type QueryIndicationsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryIndicationsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryStrengthArgs =
  | 'where'
type QueryStrengthsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryStrengthsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface QueryFieldDetails {
  user: {
    type: 'User'
    args: Record<QueryUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  users: {
    type: 'User'
    args: Record<QueryUsersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User[]> | prisma.User[]
  }
  usersConnection: {
    type: 'UserConnection'
    args: Record<QueryUsersConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserConnection> | prisma.UserConnection
  }
  event: {
    type: 'Event'
    args: Record<QueryEventArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: EventWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event | null> | prisma.Event | null
  }
  events: {
    type: 'Event'
    args: Record<QueryEventsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: EventWhereInput | null, orderBy?: prisma.EventOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event[]> | prisma.Event[]
  }
  eventsConnection: {
    type: 'EventConnection'
    args: Record<QueryEventsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: EventWhereInput | null, orderBy?: prisma.EventOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.EventConnection> | prisma.EventConnection
  }
  category: {
    type: 'Category'
    args: Record<QueryCategoryArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: CategoryWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category | null> | prisma.Category | null
  }
  categories: {
    type: 'Category'
    args: Record<QueryCategoriesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CategoryWhereInput | null, orderBy?: prisma.CategoryOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category[]> | prisma.Category[]
  }
  categoriesConnection: {
    type: 'CategoryConnection'
    args: Record<QueryCategoriesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CategoryWhereInput | null, orderBy?: prisma.CategoryOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CategoryConnection> | prisma.CategoryConnection
  }
  keyword: {
    type: 'Keyword'
    args: Record<QueryKeywordArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: KeywordWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword | null> | prisma.Keyword | null
  }
  keywords: {
    type: 'Keyword'
    args: Record<QueryKeywordsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: KeywordWhereInput | null, orderBy?: prisma.KeywordOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword[]> | prisma.Keyword[]
  }
  keywordsConnection: {
    type: 'KeywordConnection'
    args: Record<QueryKeywordsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: KeywordWhereInput | null, orderBy?: prisma.KeywordOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.KeywordConnection> | prisma.KeywordConnection
  }
  scenario: {
    type: 'Scenario'
    args: Record<QueryScenarioArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: ScenarioWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario | null> | prisma.Scenario | null
  }
  scenarios: {
    type: 'Scenario'
    args: Record<QueryScenariosArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: ScenarioWhereInput | null, orderBy?: prisma.ScenarioOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario[]> | prisma.Scenario[]
  }
  scenariosConnection: {
    type: 'ScenarioConnection'
    args: Record<QueryScenariosConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: ScenarioWhereInput | null, orderBy?: prisma.ScenarioOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ScenarioConnection> | prisma.ScenarioConnection
  }
  indicator: {
    type: 'Indicator'
    args: Record<QueryIndicatorArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: IndicatorWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator | null> | prisma.Indicator | null
  }
  indicators: {
    type: 'Indicator'
    args: Record<QueryIndicatorsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: IndicatorWhereInput | null, orderBy?: prisma.IndicatorOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator[]> | prisma.Indicator[]
  }
  indicatorsConnection: {
    type: 'IndicatorConnection'
    args: Record<QueryIndicatorsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: IndicatorWhereInput | null, orderBy?: prisma.IndicatorOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IndicatorConnection> | prisma.IndicatorConnection
  }
  indication: {
    type: 'Indication'
    args: Record<QueryIndicationArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: IndicationWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication | null> | prisma.Indication | null
  }
  indications: {
    type: 'Indication'
    args: Record<QueryIndicationsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: IndicationWhereInput | null, orderBy?: prisma.IndicationOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication[]> | prisma.Indication[]
  }
  indicationsConnection: {
    type: 'IndicationConnection'
    args: Record<QueryIndicationsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: IndicationWhereInput | null, orderBy?: prisma.IndicationOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IndicationConnection> | prisma.IndicationConnection
  }
  strength: {
    type: 'Strength'
    args: Record<QueryStrengthArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: StrengthWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength | null> | prisma.Strength | null
  }
  strengths: {
    type: 'Strength'
    args: Record<QueryStrengthsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: StrengthWhereInput | null, orderBy?: prisma.StrengthOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength[]> | prisma.Strength[]
  }
  strengthsConnection: {
    type: 'StrengthConnection'
    args: Record<QueryStrengthsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: StrengthWhereInput | null, orderBy?: prisma.StrengthOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.StrengthConnection> | prisma.StrengthConnection
  }
}
  

// Types for User

type UserObject =
  | UserFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type UserFields =
  | 'id'
  | 'name'



  

export interface UserFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for UserConnection

type UserConnectionObject =
  | UserConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type UserConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface UserConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'UserEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserEdge[]> | prisma.UserEdge[]
  }
  aggregate: {
    type: 'AggregateUser'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateUser> | prisma.AggregateUser
  }
}
  

// Types for PageInfo

type PageInfoObject =
  | PageInfoFields
  | { name: 'hasNextPage', args?: [] | false, alias?: string  } 
  | { name: 'hasPreviousPage', args?: [] | false, alias?: string  } 
  | { name: 'startCursor', args?: [] | false, alias?: string  } 
  | { name: 'endCursor', args?: [] | false, alias?: string  } 

type PageInfoFields =
  | 'hasNextPage'
  | 'hasPreviousPage'
  | 'startCursor'
  | 'endCursor'



  

export interface PageInfoFieldDetails {
  hasNextPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  hasPreviousPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  endCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for UserEdge

type UserEdgeObject =
  | UserEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type UserEdgeFields =
  | 'node'
  | 'cursor'



  

export interface UserEdgeFieldDetails {
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateUser

type AggregateUserObject =
  | AggregateUserFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateUserFields =
  | 'count'



  

export interface AggregateUserFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Event

type EventObject =
  | EventFields
  | { name: 'date', args?: [] | false, alias?: string  } 
  | { name: 'title', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 
  | { name: 'href', args?: [] | false, alias?: string  } 
  | { name: 'source', args?: [] | false, alias?: string  } 
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'read', args?: [] | false, alias?: string  } 
  | { name: 'indications', args?: EventIndicationsArgs[] | false, alias?: string  } 
  | { name: 'categories', args?: EventCategoriesArgs[] | false, alias?: string  } 

type EventFields =
  | 'date'
  | 'title'
  | 'description'
  | 'href'
  | 'source'
  | 'id'
  | 'read'
  | 'indications'
  | 'categories'


type EventIndicationsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type EventCategoriesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface EventFieldDetails {
  date: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  title: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  href: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  source: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  read: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  indications: {
    type: 'Indication'
    args: Record<EventIndicationsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Event">,
      args: { where?: IndicationWhereInput | null, orderBy?: prisma.IndicationOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication[]> | prisma.Indication[]
  }
  categories: {
    type: 'Category'
    args: Record<EventCategoriesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Event">,
      args: { where?: CategoryWhereInput | null, orderBy?: prisma.CategoryOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category[]> | prisma.Category[]
  }
}
  

// Types for Indication

type IndicationObject =
  | IndicationFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'indicator', args?: [] | false, alias?: string  } 
  | { name: 'event', args?: [] | false, alias?: string  } 
  | { name: 'strength', args?: [] | false, alias?: string  } 
  | { name: 'createdAt', args?: [] | false, alias?: string  } 
  | { name: 'updatedAt', args?: [] | false, alias?: string  } 

type IndicationFields =
  | 'id'
  | 'indicator'
  | 'event'
  | 'strength'
  | 'createdAt'
  | 'updatedAt'



  

export interface IndicationFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  indicator: {
    type: 'Indicator'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Indication">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator> | prisma.Indicator
  }
  event: {
    type: 'Event'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Indication">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event> | prisma.Event
  }
  strength: {
    type: 'Strength'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Indication">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength> | prisma.Strength
  }
  createdAt: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  updatedAt: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Indicator

type IndicatorObject =
  | IndicatorFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 
  | { name: 'keywords', args?: IndicatorKeywordsArgs[] | false, alias?: string  } 
  | { name: 'scenarios', args?: IndicatorScenariosArgs[] | false, alias?: string  } 

type IndicatorFields =
  | 'id'
  | 'name'
  | 'description'
  | 'keywords'
  | 'scenarios'


type IndicatorKeywordsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type IndicatorScenariosArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface IndicatorFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  keywords: {
    type: 'Keyword'
    args: Record<IndicatorKeywordsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Indicator">,
      args: { where?: KeywordWhereInput | null, orderBy?: prisma.KeywordOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword[]> | prisma.Keyword[]
  }
  scenarios: {
    type: 'Scenario'
    args: Record<IndicatorScenariosArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Indicator">,
      args: { where?: ScenarioWhereInput | null, orderBy?: prisma.ScenarioOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario[]> | prisma.Scenario[]
  }
}
  

// Types for Keyword

type KeywordObject =
  | KeywordFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 
  | { name: 'indicators', args?: KeywordIndicatorsArgs[] | false, alias?: string  } 

type KeywordFields =
  | 'id'
  | 'name'
  | 'description'
  | 'indicators'


type KeywordIndicatorsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface KeywordFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  indicators: {
    type: 'Indicator'
    args: Record<KeywordIndicatorsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Keyword">,
      args: { where?: IndicatorWhereInput | null, orderBy?: prisma.IndicatorOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator[]> | prisma.Indicator[]
  }
}
  

// Types for Scenario

type ScenarioObject =
  | ScenarioFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 
  | { name: 'indicators', args?: ScenarioIndicatorsArgs[] | false, alias?: string  } 

type ScenarioFields =
  | 'id'
  | 'name'
  | 'description'
  | 'indicators'


type ScenarioIndicatorsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface ScenarioFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  indicators: {
    type: 'Indicator'
    args: Record<ScenarioIndicatorsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Scenario">,
      args: { where?: IndicatorWhereInput | null, orderBy?: prisma.IndicatorOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator[]> | prisma.Indicator[]
  }
}
  

// Types for Strength

type StrengthObject =
  | StrengthFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'strength', args?: [] | false, alias?: string  } 
  | { name: 'meaning', args?: [] | false, alias?: string  } 

type StrengthFields =
  | 'id'
  | 'strength'
  | 'meaning'



  

export interface StrengthFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  strength: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  meaning: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for Category

type CategoryObject =
  | CategoryFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'events', args?: CategoryEventsArgs[] | false, alias?: string  } 

type CategoryFields =
  | 'id'
  | 'name'
  | 'events'


type CategoryEventsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface CategoryFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  events: {
    type: 'Event'
    args: Record<CategoryEventsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Category">,
      args: { where?: EventWhereInput | null, orderBy?: prisma.EventOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event[]> | prisma.Event[]
  }
}
  

// Types for EventConnection

type EventConnectionObject =
  | EventConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type EventConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface EventConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"EventConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'EventEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"EventConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.EventEdge[]> | prisma.EventEdge[]
  }
  aggregate: {
    type: 'AggregateEvent'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"EventConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateEvent> | prisma.AggregateEvent
  }
}
  

// Types for EventEdge

type EventEdgeObject =
  | EventEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type EventEdgeFields =
  | 'node'
  | 'cursor'



  

export interface EventEdgeFieldDetails {
  node: {
    type: 'Event'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"EventEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event> | prisma.Event
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateEvent

type AggregateEventObject =
  | AggregateEventFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateEventFields =
  | 'count'



  

export interface AggregateEventFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CategoryConnection

type CategoryConnectionObject =
  | CategoryConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type CategoryConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface CategoryConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CategoryConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'CategoryEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"CategoryConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CategoryEdge[]> | prisma.CategoryEdge[]
  }
  aggregate: {
    type: 'AggregateCategory'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CategoryConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateCategory> | prisma.AggregateCategory
  }
}
  

// Types for CategoryEdge

type CategoryEdgeObject =
  | CategoryEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type CategoryEdgeFields =
  | 'node'
  | 'cursor'



  

export interface CategoryEdgeFieldDetails {
  node: {
    type: 'Category'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CategoryEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category> | prisma.Category
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateCategory

type AggregateCategoryObject =
  | AggregateCategoryFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateCategoryFields =
  | 'count'



  

export interface AggregateCategoryFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for KeywordConnection

type KeywordConnectionObject =
  | KeywordConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type KeywordConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface KeywordConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"KeywordConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'KeywordEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"KeywordConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.KeywordEdge[]> | prisma.KeywordEdge[]
  }
  aggregate: {
    type: 'AggregateKeyword'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"KeywordConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateKeyword> | prisma.AggregateKeyword
  }
}
  

// Types for KeywordEdge

type KeywordEdgeObject =
  | KeywordEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type KeywordEdgeFields =
  | 'node'
  | 'cursor'



  

export interface KeywordEdgeFieldDetails {
  node: {
    type: 'Keyword'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"KeywordEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword> | prisma.Keyword
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateKeyword

type AggregateKeywordObject =
  | AggregateKeywordFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateKeywordFields =
  | 'count'



  

export interface AggregateKeywordFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for ScenarioConnection

type ScenarioConnectionObject =
  | ScenarioConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type ScenarioConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface ScenarioConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ScenarioConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'ScenarioEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"ScenarioConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ScenarioEdge[]> | prisma.ScenarioEdge[]
  }
  aggregate: {
    type: 'AggregateScenario'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ScenarioConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateScenario> | prisma.AggregateScenario
  }
}
  

// Types for ScenarioEdge

type ScenarioEdgeObject =
  | ScenarioEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type ScenarioEdgeFields =
  | 'node'
  | 'cursor'



  

export interface ScenarioEdgeFieldDetails {
  node: {
    type: 'Scenario'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ScenarioEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario> | prisma.Scenario
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateScenario

type AggregateScenarioObject =
  | AggregateScenarioFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateScenarioFields =
  | 'count'



  

export interface AggregateScenarioFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for IndicatorConnection

type IndicatorConnectionObject =
  | IndicatorConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type IndicatorConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface IndicatorConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"IndicatorConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'IndicatorEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"IndicatorConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IndicatorEdge[]> | prisma.IndicatorEdge[]
  }
  aggregate: {
    type: 'AggregateIndicator'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"IndicatorConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateIndicator> | prisma.AggregateIndicator
  }
}
  

// Types for IndicatorEdge

type IndicatorEdgeObject =
  | IndicatorEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type IndicatorEdgeFields =
  | 'node'
  | 'cursor'



  

export interface IndicatorEdgeFieldDetails {
  node: {
    type: 'Indicator'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"IndicatorEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator> | prisma.Indicator
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateIndicator

type AggregateIndicatorObject =
  | AggregateIndicatorFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateIndicatorFields =
  | 'count'



  

export interface AggregateIndicatorFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for IndicationConnection

type IndicationConnectionObject =
  | IndicationConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type IndicationConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface IndicationConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"IndicationConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'IndicationEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"IndicationConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IndicationEdge[]> | prisma.IndicationEdge[]
  }
  aggregate: {
    type: 'AggregateIndication'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"IndicationConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateIndication> | prisma.AggregateIndication
  }
}
  

// Types for IndicationEdge

type IndicationEdgeObject =
  | IndicationEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type IndicationEdgeFields =
  | 'node'
  | 'cursor'



  

export interface IndicationEdgeFieldDetails {
  node: {
    type: 'Indication'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"IndicationEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication> | prisma.Indication
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateIndication

type AggregateIndicationObject =
  | AggregateIndicationFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateIndicationFields =
  | 'count'



  

export interface AggregateIndicationFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for StrengthConnection

type StrengthConnectionObject =
  | StrengthConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type StrengthConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface StrengthConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"StrengthConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'StrengthEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"StrengthConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.StrengthEdge[]> | prisma.StrengthEdge[]
  }
  aggregate: {
    type: 'AggregateStrength'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"StrengthConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateStrength> | prisma.AggregateStrength
  }
}
  

// Types for StrengthEdge

type StrengthEdgeObject =
  | StrengthEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type StrengthEdgeFields =
  | 'node'
  | 'cursor'



  

export interface StrengthEdgeFieldDetails {
  node: {
    type: 'Strength'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"StrengthEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength> | prisma.Strength
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateStrength

type AggregateStrengthObject =
  | AggregateStrengthFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateStrengthFields =
  | 'count'



  

export interface AggregateStrengthFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Mutation

type MutationObject =
  | MutationFields
  | { name: 'createUser', args?: MutationCreateUserArgs[] | false, alias?: string  } 
  | { name: 'updateUser', args?: MutationUpdateUserArgs[] | false, alias?: string  } 
  | { name: 'updateManyUsers', args?: MutationUpdateManyUsersArgs[] | false, alias?: string  } 
  | { name: 'upsertUser', args?: MutationUpsertUserArgs[] | false, alias?: string  } 
  | { name: 'deleteUser', args?: MutationDeleteUserArgs[] | false, alias?: string  } 
  | { name: 'deleteManyUsers', args?: MutationDeleteManyUsersArgs[] | false, alias?: string  } 
  | { name: 'createEvent', args?: MutationCreateEventArgs[] | false, alias?: string  } 
  | { name: 'updateEvent', args?: MutationUpdateEventArgs[] | false, alias?: string  } 
  | { name: 'updateManyEvents', args?: MutationUpdateManyEventsArgs[] | false, alias?: string  } 
  | { name: 'upsertEvent', args?: MutationUpsertEventArgs[] | false, alias?: string  } 
  | { name: 'deleteEvent', args?: MutationDeleteEventArgs[] | false, alias?: string  } 
  | { name: 'deleteManyEvents', args?: MutationDeleteManyEventsArgs[] | false, alias?: string  } 
  | { name: 'createCategory', args?: MutationCreateCategoryArgs[] | false, alias?: string  } 
  | { name: 'updateCategory', args?: MutationUpdateCategoryArgs[] | false, alias?: string  } 
  | { name: 'updateManyCategories', args?: MutationUpdateManyCategoriesArgs[] | false, alias?: string  } 
  | { name: 'upsertCategory', args?: MutationUpsertCategoryArgs[] | false, alias?: string  } 
  | { name: 'deleteCategory', args?: MutationDeleteCategoryArgs[] | false, alias?: string  } 
  | { name: 'deleteManyCategories', args?: MutationDeleteManyCategoriesArgs[] | false, alias?: string  } 
  | { name: 'createKeyword', args?: MutationCreateKeywordArgs[] | false, alias?: string  } 
  | { name: 'updateKeyword', args?: MutationUpdateKeywordArgs[] | false, alias?: string  } 
  | { name: 'updateManyKeywords', args?: MutationUpdateManyKeywordsArgs[] | false, alias?: string  } 
  | { name: 'upsertKeyword', args?: MutationUpsertKeywordArgs[] | false, alias?: string  } 
  | { name: 'deleteKeyword', args?: MutationDeleteKeywordArgs[] | false, alias?: string  } 
  | { name: 'deleteManyKeywords', args?: MutationDeleteManyKeywordsArgs[] | false, alias?: string  } 
  | { name: 'createScenario', args?: MutationCreateScenarioArgs[] | false, alias?: string  } 
  | { name: 'updateScenario', args?: MutationUpdateScenarioArgs[] | false, alias?: string  } 
  | { name: 'updateManyScenarios', args?: MutationUpdateManyScenariosArgs[] | false, alias?: string  } 
  | { name: 'upsertScenario', args?: MutationUpsertScenarioArgs[] | false, alias?: string  } 
  | { name: 'deleteScenario', args?: MutationDeleteScenarioArgs[] | false, alias?: string  } 
  | { name: 'deleteManyScenarios', args?: MutationDeleteManyScenariosArgs[] | false, alias?: string  } 
  | { name: 'createIndicator', args?: MutationCreateIndicatorArgs[] | false, alias?: string  } 
  | { name: 'updateIndicator', args?: MutationUpdateIndicatorArgs[] | false, alias?: string  } 
  | { name: 'updateManyIndicators', args?: MutationUpdateManyIndicatorsArgs[] | false, alias?: string  } 
  | { name: 'upsertIndicator', args?: MutationUpsertIndicatorArgs[] | false, alias?: string  } 
  | { name: 'deleteIndicator', args?: MutationDeleteIndicatorArgs[] | false, alias?: string  } 
  | { name: 'deleteManyIndicators', args?: MutationDeleteManyIndicatorsArgs[] | false, alias?: string  } 
  | { name: 'createIndication', args?: MutationCreateIndicationArgs[] | false, alias?: string  } 
  | { name: 'updateIndication', args?: MutationUpdateIndicationArgs[] | false, alias?: string  } 
  | { name: 'upsertIndication', args?: MutationUpsertIndicationArgs[] | false, alias?: string  } 
  | { name: 'deleteIndication', args?: MutationDeleteIndicationArgs[] | false, alias?: string  } 
  | { name: 'deleteManyIndications', args?: MutationDeleteManyIndicationsArgs[] | false, alias?: string  } 
  | { name: 'createStrength', args?: MutationCreateStrengthArgs[] | false, alias?: string  } 
  | { name: 'updateStrength', args?: MutationUpdateStrengthArgs[] | false, alias?: string  } 
  | { name: 'updateManyStrengths', args?: MutationUpdateManyStrengthsArgs[] | false, alias?: string  } 
  | { name: 'upsertStrength', args?: MutationUpsertStrengthArgs[] | false, alias?: string  } 
  | { name: 'deleteStrength', args?: MutationDeleteStrengthArgs[] | false, alias?: string  } 
  | { name: 'deleteManyStrengths', args?: MutationDeleteManyStrengthsArgs[] | false, alias?: string  } 

type MutationFields =
  | 'createUser'
  | 'updateUser'
  | 'updateManyUsers'
  | 'upsertUser'
  | 'deleteUser'
  | 'deleteManyUsers'
  | 'createEvent'
  | 'updateEvent'
  | 'updateManyEvents'
  | 'upsertEvent'
  | 'deleteEvent'
  | 'deleteManyEvents'
  | 'createCategory'
  | 'updateCategory'
  | 'updateManyCategories'
  | 'upsertCategory'
  | 'deleteCategory'
  | 'deleteManyCategories'
  | 'createKeyword'
  | 'updateKeyword'
  | 'updateManyKeywords'
  | 'upsertKeyword'
  | 'deleteKeyword'
  | 'deleteManyKeywords'
  | 'createScenario'
  | 'updateScenario'
  | 'updateManyScenarios'
  | 'upsertScenario'
  | 'deleteScenario'
  | 'deleteManyScenarios'
  | 'createIndicator'
  | 'updateIndicator'
  | 'updateManyIndicators'
  | 'upsertIndicator'
  | 'deleteIndicator'
  | 'deleteManyIndicators'
  | 'createIndication'
  | 'updateIndication'
  | 'upsertIndication'
  | 'deleteIndication'
  | 'deleteManyIndications'
  | 'createStrength'
  | 'updateStrength'
  | 'updateManyStrengths'
  | 'upsertStrength'
  | 'deleteStrength'
  | 'deleteManyStrengths'


type MutationCreateUserArgs =
  | 'data'
type MutationUpdateUserArgs =
  | 'data'
  | 'where'
type MutationUpdateManyUsersArgs =
  | 'data'
  | 'where'
type MutationUpsertUserArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteUserArgs =
  | 'where'
type MutationDeleteManyUsersArgs =
  | 'where'
type MutationCreateEventArgs =
  | 'data'
type MutationUpdateEventArgs =
  | 'data'
  | 'where'
type MutationUpdateManyEventsArgs =
  | 'data'
  | 'where'
type MutationUpsertEventArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteEventArgs =
  | 'where'
type MutationDeleteManyEventsArgs =
  | 'where'
type MutationCreateCategoryArgs =
  | 'data'
type MutationUpdateCategoryArgs =
  | 'data'
  | 'where'
type MutationUpdateManyCategoriesArgs =
  | 'data'
  | 'where'
type MutationUpsertCategoryArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteCategoryArgs =
  | 'where'
type MutationDeleteManyCategoriesArgs =
  | 'where'
type MutationCreateKeywordArgs =
  | 'data'
type MutationUpdateKeywordArgs =
  | 'data'
  | 'where'
type MutationUpdateManyKeywordsArgs =
  | 'data'
  | 'where'
type MutationUpsertKeywordArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteKeywordArgs =
  | 'where'
type MutationDeleteManyKeywordsArgs =
  | 'where'
type MutationCreateScenarioArgs =
  | 'data'
type MutationUpdateScenarioArgs =
  | 'data'
  | 'where'
type MutationUpdateManyScenariosArgs =
  | 'data'
  | 'where'
type MutationUpsertScenarioArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteScenarioArgs =
  | 'where'
type MutationDeleteManyScenariosArgs =
  | 'where'
type MutationCreateIndicatorArgs =
  | 'data'
type MutationUpdateIndicatorArgs =
  | 'data'
  | 'where'
type MutationUpdateManyIndicatorsArgs =
  | 'data'
  | 'where'
type MutationUpsertIndicatorArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteIndicatorArgs =
  | 'where'
type MutationDeleteManyIndicatorsArgs =
  | 'where'
type MutationCreateIndicationArgs =
  | 'data'
type MutationUpdateIndicationArgs =
  | 'data'
  | 'where'
type MutationUpsertIndicationArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteIndicationArgs =
  | 'where'
type MutationDeleteManyIndicationsArgs =
  | 'where'
type MutationCreateStrengthArgs =
  | 'data'
type MutationUpdateStrengthArgs =
  | 'data'
  | 'where'
type MutationUpdateManyStrengthsArgs =
  | 'data'
  | 'where'
type MutationUpsertStrengthArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteStrengthArgs =
  | 'where'
type MutationDeleteManyStrengthsArgs =
  | 'where'
  

export interface MutationFieldDetails {
  createUser: {
    type: 'User'
    args: Record<MutationCreateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  updateUser: {
    type: 'User'
    args: Record<MutationUpdateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateInput, where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updateManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateManyMutationInput, where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertUser: {
    type: 'User'
    args: Record<MutationUpsertUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput, create: UserCreateInput, update: UserUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  deleteUser: {
    type: 'User'
    args: Record<MutationDeleteUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  deleteManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createEvent: {
    type: 'Event'
    args: Record<MutationCreateEventArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: EventCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event> | prisma.Event
  }
  updateEvent: {
    type: 'Event'
    args: Record<MutationUpdateEventArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: EventUpdateInput, where: EventWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event | null> | prisma.Event | null
  }
  updateManyEvents: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyEventsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: EventUpdateManyMutationInput, where?: EventWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertEvent: {
    type: 'Event'
    args: Record<MutationUpsertEventArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: EventWhereUniqueInput, create: EventCreateInput, update: EventUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event> | prisma.Event
  }
  deleteEvent: {
    type: 'Event'
    args: Record<MutationDeleteEventArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: EventWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event | null> | prisma.Event | null
  }
  deleteManyEvents: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyEventsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: EventWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createCategory: {
    type: 'Category'
    args: Record<MutationCreateCategoryArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CategoryCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category> | prisma.Category
  }
  updateCategory: {
    type: 'Category'
    args: Record<MutationUpdateCategoryArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CategoryUpdateInput, where: CategoryWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category | null> | prisma.Category | null
  }
  updateManyCategories: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyCategoriesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CategoryUpdateManyMutationInput, where?: CategoryWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertCategory: {
    type: 'Category'
    args: Record<MutationUpsertCategoryArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CategoryWhereUniqueInput, create: CategoryCreateInput, update: CategoryUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category> | prisma.Category
  }
  deleteCategory: {
    type: 'Category'
    args: Record<MutationDeleteCategoryArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CategoryWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category | null> | prisma.Category | null
  }
  deleteManyCategories: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyCategoriesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: CategoryWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createKeyword: {
    type: 'Keyword'
    args: Record<MutationCreateKeywordArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: KeywordCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword> | prisma.Keyword
  }
  updateKeyword: {
    type: 'Keyword'
    args: Record<MutationUpdateKeywordArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: KeywordUpdateInput, where: KeywordWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword | null> | prisma.Keyword | null
  }
  updateManyKeywords: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyKeywordsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: KeywordUpdateManyMutationInput, where?: KeywordWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertKeyword: {
    type: 'Keyword'
    args: Record<MutationUpsertKeywordArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: KeywordWhereUniqueInput, create: KeywordCreateInput, update: KeywordUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword> | prisma.Keyword
  }
  deleteKeyword: {
    type: 'Keyword'
    args: Record<MutationDeleteKeywordArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: KeywordWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword | null> | prisma.Keyword | null
  }
  deleteManyKeywords: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyKeywordsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: KeywordWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createScenario: {
    type: 'Scenario'
    args: Record<MutationCreateScenarioArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ScenarioCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario> | prisma.Scenario
  }
  updateScenario: {
    type: 'Scenario'
    args: Record<MutationUpdateScenarioArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ScenarioUpdateInput, where: ScenarioWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario | null> | prisma.Scenario | null
  }
  updateManyScenarios: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyScenariosArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ScenarioUpdateManyMutationInput, where?: ScenarioWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertScenario: {
    type: 'Scenario'
    args: Record<MutationUpsertScenarioArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: ScenarioWhereUniqueInput, create: ScenarioCreateInput, update: ScenarioUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario> | prisma.Scenario
  }
  deleteScenario: {
    type: 'Scenario'
    args: Record<MutationDeleteScenarioArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: ScenarioWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario | null> | prisma.Scenario | null
  }
  deleteManyScenarios: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyScenariosArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: ScenarioWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createIndicator: {
    type: 'Indicator'
    args: Record<MutationCreateIndicatorArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: IndicatorCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator> | prisma.Indicator
  }
  updateIndicator: {
    type: 'Indicator'
    args: Record<MutationUpdateIndicatorArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: IndicatorUpdateInput, where: IndicatorWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator | null> | prisma.Indicator | null
  }
  updateManyIndicators: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyIndicatorsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: IndicatorUpdateManyMutationInput, where?: IndicatorWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertIndicator: {
    type: 'Indicator'
    args: Record<MutationUpsertIndicatorArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: IndicatorWhereUniqueInput, create: IndicatorCreateInput, update: IndicatorUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator> | prisma.Indicator
  }
  deleteIndicator: {
    type: 'Indicator'
    args: Record<MutationDeleteIndicatorArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: IndicatorWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator | null> | prisma.Indicator | null
  }
  deleteManyIndicators: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyIndicatorsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: IndicatorWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createIndication: {
    type: 'Indication'
    args: Record<MutationCreateIndicationArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: IndicationCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication> | prisma.Indication
  }
  updateIndication: {
    type: 'Indication'
    args: Record<MutationUpdateIndicationArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: IndicationUpdateInput, where: IndicationWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication | null> | prisma.Indication | null
  }
  upsertIndication: {
    type: 'Indication'
    args: Record<MutationUpsertIndicationArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: IndicationWhereUniqueInput, create: IndicationCreateInput, update: IndicationUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication> | prisma.Indication
  }
  deleteIndication: {
    type: 'Indication'
    args: Record<MutationDeleteIndicationArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: IndicationWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication | null> | prisma.Indication | null
  }
  deleteManyIndications: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyIndicationsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: IndicationWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createStrength: {
    type: 'Strength'
    args: Record<MutationCreateStrengthArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: StrengthCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength> | prisma.Strength
  }
  updateStrength: {
    type: 'Strength'
    args: Record<MutationUpdateStrengthArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: StrengthUpdateInput, where: StrengthWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength | null> | prisma.Strength | null
  }
  updateManyStrengths: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyStrengthsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: StrengthUpdateManyMutationInput, where?: StrengthWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertStrength: {
    type: 'Strength'
    args: Record<MutationUpsertStrengthArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: StrengthWhereUniqueInput, create: StrengthCreateInput, update: StrengthUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength> | prisma.Strength
  }
  deleteStrength: {
    type: 'Strength'
    args: Record<MutationDeleteStrengthArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: StrengthWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength | null> | prisma.Strength | null
  }
  deleteManyStrengths: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyStrengthsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: StrengthWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
}
  

// Types for BatchPayload

type BatchPayloadObject =
  | BatchPayloadFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type BatchPayloadFields =
  | 'count'



  

export interface BatchPayloadFieldDetails {
  count: {
    type: 'Long'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Subscription

type SubscriptionObject =
  | SubscriptionFields
  | { name: 'user', args?: SubscriptionUserArgs[] | false, alias?: string  } 
  | { name: 'event', args?: SubscriptionEventArgs[] | false, alias?: string  } 
  | { name: 'category', args?: SubscriptionCategoryArgs[] | false, alias?: string  } 
  | { name: 'keyword', args?: SubscriptionKeywordArgs[] | false, alias?: string  } 
  | { name: 'scenario', args?: SubscriptionScenarioArgs[] | false, alias?: string  } 
  | { name: 'indicator', args?: SubscriptionIndicatorArgs[] | false, alias?: string  } 
  | { name: 'indication', args?: SubscriptionIndicationArgs[] | false, alias?: string  } 
  | { name: 'strength', args?: SubscriptionStrengthArgs[] | false, alias?: string  } 

type SubscriptionFields =
  | 'user'
  | 'event'
  | 'category'
  | 'keyword'
  | 'scenario'
  | 'indicator'
  | 'indication'
  | 'strength'


type SubscriptionUserArgs =
  | 'where'
type SubscriptionEventArgs =
  | 'where'
type SubscriptionCategoryArgs =
  | 'where'
type SubscriptionKeywordArgs =
  | 'where'
type SubscriptionScenarioArgs =
  | 'where'
type SubscriptionIndicatorArgs =
  | 'where'
type SubscriptionIndicationArgs =
  | 'where'
type SubscriptionStrengthArgs =
  | 'where'
  

export interface SubscriptionFieldDetails {
  user: {
    type: 'UserSubscriptionPayload'
    args: Record<SubscriptionUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: UserSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserSubscriptionPayload | null> | prisma.UserSubscriptionPayload | null
  }
  event: {
    type: 'EventSubscriptionPayload'
    args: Record<SubscriptionEventArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: EventSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.EventSubscriptionPayload | null> | prisma.EventSubscriptionPayload | null
  }
  category: {
    type: 'CategorySubscriptionPayload'
    args: Record<SubscriptionCategoryArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: CategorySubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CategorySubscriptionPayload | null> | prisma.CategorySubscriptionPayload | null
  }
  keyword: {
    type: 'KeywordSubscriptionPayload'
    args: Record<SubscriptionKeywordArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: KeywordSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.KeywordSubscriptionPayload | null> | prisma.KeywordSubscriptionPayload | null
  }
  scenario: {
    type: 'ScenarioSubscriptionPayload'
    args: Record<SubscriptionScenarioArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: ScenarioSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ScenarioSubscriptionPayload | null> | prisma.ScenarioSubscriptionPayload | null
  }
  indicator: {
    type: 'IndicatorSubscriptionPayload'
    args: Record<SubscriptionIndicatorArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: IndicatorSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IndicatorSubscriptionPayload | null> | prisma.IndicatorSubscriptionPayload | null
  }
  indication: {
    type: 'IndicationSubscriptionPayload'
    args: Record<SubscriptionIndicationArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: IndicationSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IndicationSubscriptionPayload | null> | prisma.IndicationSubscriptionPayload | null
  }
  strength: {
    type: 'StrengthSubscriptionPayload'
    args: Record<SubscriptionStrengthArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: StrengthSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.StrengthSubscriptionPayload | null> | prisma.StrengthSubscriptionPayload | null
  }
}
  

// Types for UserSubscriptionPayload

type UserSubscriptionPayloadObject =
  | UserSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type UserSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface UserSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'UserPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserPreviousValues | null> | prisma.UserPreviousValues | null
  }
}
  

// Types for UserPreviousValues

type UserPreviousValuesObject =
  | UserPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type UserPreviousValuesFields =
  | 'id'
  | 'name'



  

export interface UserPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for EventSubscriptionPayload

type EventSubscriptionPayloadObject =
  | EventSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type EventSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface EventSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"EventSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Event'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"EventSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Event | null> | prisma.Event | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'EventPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"EventSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.EventPreviousValues | null> | prisma.EventPreviousValues | null
  }
}
  

// Types for EventPreviousValues

type EventPreviousValuesObject =
  | EventPreviousValuesFields
  | { name: 'date', args?: [] | false, alias?: string  } 
  | { name: 'title', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 
  | { name: 'href', args?: [] | false, alias?: string  } 
  | { name: 'source', args?: [] | false, alias?: string  } 
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'read', args?: [] | false, alias?: string  } 

type EventPreviousValuesFields =
  | 'date'
  | 'title'
  | 'description'
  | 'href'
  | 'source'
  | 'id'
  | 'read'



  

export interface EventPreviousValuesFieldDetails {
  date: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  title: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  href: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  source: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  read: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for CategorySubscriptionPayload

type CategorySubscriptionPayloadObject =
  | CategorySubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type CategorySubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface CategorySubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CategorySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Category'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CategorySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Category | null> | prisma.Category | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'CategoryPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CategorySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CategoryPreviousValues | null> | prisma.CategoryPreviousValues | null
  }
}
  

// Types for CategoryPreviousValues

type CategoryPreviousValuesObject =
  | CategoryPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type CategoryPreviousValuesFields =
  | 'id'
  | 'name'



  

export interface CategoryPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for KeywordSubscriptionPayload

type KeywordSubscriptionPayloadObject =
  | KeywordSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type KeywordSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface KeywordSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"KeywordSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Keyword'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"KeywordSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Keyword | null> | prisma.Keyword | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'KeywordPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"KeywordSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.KeywordPreviousValues | null> | prisma.KeywordPreviousValues | null
  }
}
  

// Types for KeywordPreviousValues

type KeywordPreviousValuesObject =
  | KeywordPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 

type KeywordPreviousValuesFields =
  | 'id'
  | 'name'
  | 'description'



  

export interface KeywordPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for ScenarioSubscriptionPayload

type ScenarioSubscriptionPayloadObject =
  | ScenarioSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type ScenarioSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface ScenarioSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ScenarioSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Scenario'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"ScenarioSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Scenario | null> | prisma.Scenario | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'ScenarioPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"ScenarioSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ScenarioPreviousValues | null> | prisma.ScenarioPreviousValues | null
  }
}
  

// Types for ScenarioPreviousValues

type ScenarioPreviousValuesObject =
  | ScenarioPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 

type ScenarioPreviousValuesFields =
  | 'id'
  | 'name'
  | 'description'



  

export interface ScenarioPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for IndicatorSubscriptionPayload

type IndicatorSubscriptionPayloadObject =
  | IndicatorSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type IndicatorSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface IndicatorSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"IndicatorSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Indicator'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"IndicatorSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indicator | null> | prisma.Indicator | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'IndicatorPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"IndicatorSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IndicatorPreviousValues | null> | prisma.IndicatorPreviousValues | null
  }
}
  

// Types for IndicatorPreviousValues

type IndicatorPreviousValuesObject =
  | IndicatorPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 

type IndicatorPreviousValuesFields =
  | 'id'
  | 'name'
  | 'description'



  

export interface IndicatorPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for IndicationSubscriptionPayload

type IndicationSubscriptionPayloadObject =
  | IndicationSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type IndicationSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface IndicationSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"IndicationSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Indication'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"IndicationSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Indication | null> | prisma.Indication | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'IndicationPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"IndicationSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IndicationPreviousValues | null> | prisma.IndicationPreviousValues | null
  }
}
  

// Types for IndicationPreviousValues

type IndicationPreviousValuesObject =
  | IndicationPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'createdAt', args?: [] | false, alias?: string  } 
  | { name: 'updatedAt', args?: [] | false, alias?: string  } 

type IndicationPreviousValuesFields =
  | 'id'
  | 'createdAt'
  | 'updatedAt'



  

export interface IndicationPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  createdAt: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  updatedAt: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for StrengthSubscriptionPayload

type StrengthSubscriptionPayloadObject =
  | StrengthSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type StrengthSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface StrengthSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"StrengthSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Strength'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"StrengthSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Strength | null> | prisma.Strength | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'StrengthPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"StrengthSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.StrengthPreviousValues | null> | prisma.StrengthPreviousValues | null
  }
}
  

// Types for StrengthPreviousValues

type StrengthPreviousValuesObject =
  | StrengthPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'strength', args?: [] | false, alias?: string  } 
  | { name: 'meaning', args?: [] | false, alias?: string  } 

type StrengthPreviousValuesFields =
  | 'id'
  | 'strength'
  | 'meaning'



  

export interface StrengthPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  strength: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  meaning: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  


export interface UserWhereUniqueInput {
  id?: string | null
}
export type UserWhereUniqueInputInputObject =
  | Extract<keyof UserWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface UserWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  AND?: UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput[]
}
export type UserWhereInputInputObject =
  | Extract<keyof UserWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface EventWhereUniqueInput {
  id?: string | null
}
export type EventWhereUniqueInputInputObject =
  | Extract<keyof EventWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface IndicationWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  indicator?: IndicatorWhereInput | null
  event?: EventWhereInput | null
  strength?: StrengthWhereInput | null
  createdAt?: string | null
  createdAt_not?: string | null
  createdAt_in?: string[]
  createdAt_not_in?: string[]
  createdAt_lt?: string | null
  createdAt_lte?: string | null
  createdAt_gt?: string | null
  createdAt_gte?: string | null
  updatedAt?: string | null
  updatedAt_not?: string | null
  updatedAt_in?: string[]
  updatedAt_not_in?: string[]
  updatedAt_lt?: string | null
  updatedAt_lte?: string | null
  updatedAt_gt?: string | null
  updatedAt_gte?: string | null
  AND?: IndicationWhereInput[]
  OR?: IndicationWhereInput[]
  NOT?: IndicationWhereInput[]
}
export type IndicationWhereInputInputObject =
  | Extract<keyof IndicationWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'indicator', alias?: string  } 
  | { name: 'event', alias?: string  } 
  | { name: 'strength', alias?: string  } 
  | { name: 'createdAt', alias?: string  } 
  | { name: 'createdAt_not', alias?: string  } 
  | { name: 'createdAt_in', alias?: string  } 
  | { name: 'createdAt_not_in', alias?: string  } 
  | { name: 'createdAt_lt', alias?: string  } 
  | { name: 'createdAt_lte', alias?: string  } 
  | { name: 'createdAt_gt', alias?: string  } 
  | { name: 'createdAt_gte', alias?: string  } 
  | { name: 'updatedAt', alias?: string  } 
  | { name: 'updatedAt_not', alias?: string  } 
  | { name: 'updatedAt_in', alias?: string  } 
  | { name: 'updatedAt_not_in', alias?: string  } 
  | { name: 'updatedAt_lt', alias?: string  } 
  | { name: 'updatedAt_lte', alias?: string  } 
  | { name: 'updatedAt_gt', alias?: string  } 
  | { name: 'updatedAt_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface IndicatorWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  keywords_every?: KeywordWhereInput | null
  keywords_some?: KeywordWhereInput | null
  keywords_none?: KeywordWhereInput | null
  scenarios_every?: ScenarioWhereInput | null
  scenarios_some?: ScenarioWhereInput | null
  scenarios_none?: ScenarioWhereInput | null
  AND?: IndicatorWhereInput[]
  OR?: IndicatorWhereInput[]
  NOT?: IndicatorWhereInput[]
}
export type IndicatorWhereInputInputObject =
  | Extract<keyof IndicatorWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'keywords_every', alias?: string  } 
  | { name: 'keywords_some', alias?: string  } 
  | { name: 'keywords_none', alias?: string  } 
  | { name: 'scenarios_every', alias?: string  } 
  | { name: 'scenarios_some', alias?: string  } 
  | { name: 'scenarios_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface KeywordWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  indicators_every?: IndicatorWhereInput | null
  indicators_some?: IndicatorWhereInput | null
  indicators_none?: IndicatorWhereInput | null
  AND?: KeywordWhereInput[]
  OR?: KeywordWhereInput[]
  NOT?: KeywordWhereInput[]
}
export type KeywordWhereInputInputObject =
  | Extract<keyof KeywordWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'indicators_every', alias?: string  } 
  | { name: 'indicators_some', alias?: string  } 
  | { name: 'indicators_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface ScenarioWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  indicators_every?: IndicatorWhereInput | null
  indicators_some?: IndicatorWhereInput | null
  indicators_none?: IndicatorWhereInput | null
  AND?: ScenarioWhereInput[]
  OR?: ScenarioWhereInput[]
  NOT?: ScenarioWhereInput[]
}
export type ScenarioWhereInputInputObject =
  | Extract<keyof ScenarioWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'indicators_every', alias?: string  } 
  | { name: 'indicators_some', alias?: string  } 
  | { name: 'indicators_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface EventWhereInput {
  date?: string | null
  date_not?: string | null
  date_in?: string[]
  date_not_in?: string[]
  date_lt?: string | null
  date_lte?: string | null
  date_gt?: string | null
  date_gte?: string | null
  title?: string | null
  title_not?: string | null
  title_in?: string[]
  title_not_in?: string[]
  title_lt?: string | null
  title_lte?: string | null
  title_gt?: string | null
  title_gte?: string | null
  title_contains?: string | null
  title_not_contains?: string | null
  title_starts_with?: string | null
  title_not_starts_with?: string | null
  title_ends_with?: string | null
  title_not_ends_with?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  href?: string | null
  href_not?: string | null
  href_in?: string[]
  href_not_in?: string[]
  href_lt?: string | null
  href_lte?: string | null
  href_gt?: string | null
  href_gte?: string | null
  href_contains?: string | null
  href_not_contains?: string | null
  href_starts_with?: string | null
  href_not_starts_with?: string | null
  href_ends_with?: string | null
  href_not_ends_with?: string | null
  source?: string | null
  source_not?: string | null
  source_in?: string[]
  source_not_in?: string[]
  source_lt?: string | null
  source_lte?: string | null
  source_gt?: string | null
  source_gte?: string | null
  source_contains?: string | null
  source_not_contains?: string | null
  source_starts_with?: string | null
  source_not_starts_with?: string | null
  source_ends_with?: string | null
  source_not_ends_with?: string | null
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  read?: boolean | null
  read_not?: boolean | null
  indications_every?: IndicationWhereInput | null
  indications_some?: IndicationWhereInput | null
  indications_none?: IndicationWhereInput | null
  categories_every?: CategoryWhereInput | null
  categories_some?: CategoryWhereInput | null
  categories_none?: CategoryWhereInput | null
  AND?: EventWhereInput[]
  OR?: EventWhereInput[]
  NOT?: EventWhereInput[]
}
export type EventWhereInputInputObject =
  | Extract<keyof EventWhereInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'date_not', alias?: string  } 
  | { name: 'date_in', alias?: string  } 
  | { name: 'date_not_in', alias?: string  } 
  | { name: 'date_lt', alias?: string  } 
  | { name: 'date_lte', alias?: string  } 
  | { name: 'date_gt', alias?: string  } 
  | { name: 'date_gte', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'title_not', alias?: string  } 
  | { name: 'title_in', alias?: string  } 
  | { name: 'title_not_in', alias?: string  } 
  | { name: 'title_lt', alias?: string  } 
  | { name: 'title_lte', alias?: string  } 
  | { name: 'title_gt', alias?: string  } 
  | { name: 'title_gte', alias?: string  } 
  | { name: 'title_contains', alias?: string  } 
  | { name: 'title_not_contains', alias?: string  } 
  | { name: 'title_starts_with', alias?: string  } 
  | { name: 'title_not_starts_with', alias?: string  } 
  | { name: 'title_ends_with', alias?: string  } 
  | { name: 'title_not_ends_with', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'href_not', alias?: string  } 
  | { name: 'href_in', alias?: string  } 
  | { name: 'href_not_in', alias?: string  } 
  | { name: 'href_lt', alias?: string  } 
  | { name: 'href_lte', alias?: string  } 
  | { name: 'href_gt', alias?: string  } 
  | { name: 'href_gte', alias?: string  } 
  | { name: 'href_contains', alias?: string  } 
  | { name: 'href_not_contains', alias?: string  } 
  | { name: 'href_starts_with', alias?: string  } 
  | { name: 'href_not_starts_with', alias?: string  } 
  | { name: 'href_ends_with', alias?: string  } 
  | { name: 'href_not_ends_with', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'source_not', alias?: string  } 
  | { name: 'source_in', alias?: string  } 
  | { name: 'source_not_in', alias?: string  } 
  | { name: 'source_lt', alias?: string  } 
  | { name: 'source_lte', alias?: string  } 
  | { name: 'source_gt', alias?: string  } 
  | { name: 'source_gte', alias?: string  } 
  | { name: 'source_contains', alias?: string  } 
  | { name: 'source_not_contains', alias?: string  } 
  | { name: 'source_starts_with', alias?: string  } 
  | { name: 'source_not_starts_with', alias?: string  } 
  | { name: 'source_ends_with', alias?: string  } 
  | { name: 'source_not_ends_with', alias?: string  } 
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'read', alias?: string  } 
  | { name: 'read_not', alias?: string  } 
  | { name: 'indications_every', alias?: string  } 
  | { name: 'indications_some', alias?: string  } 
  | { name: 'indications_none', alias?: string  } 
  | { name: 'categories_every', alias?: string  } 
  | { name: 'categories_some', alias?: string  } 
  | { name: 'categories_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CategoryWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  events_every?: EventWhereInput | null
  events_some?: EventWhereInput | null
  events_none?: EventWhereInput | null
  AND?: CategoryWhereInput[]
  OR?: CategoryWhereInput[]
  NOT?: CategoryWhereInput[]
}
export type CategoryWhereInputInputObject =
  | Extract<keyof CategoryWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'events_every', alias?: string  } 
  | { name: 'events_some', alias?: string  } 
  | { name: 'events_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface StrengthWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  strength?: number | null
  strength_not?: number | null
  strength_in?: number[]
  strength_not_in?: number[]
  strength_lt?: number | null
  strength_lte?: number | null
  strength_gt?: number | null
  strength_gte?: number | null
  meaning?: string | null
  meaning_not?: string | null
  meaning_in?: string[]
  meaning_not_in?: string[]
  meaning_lt?: string | null
  meaning_lte?: string | null
  meaning_gt?: string | null
  meaning_gte?: string | null
  meaning_contains?: string | null
  meaning_not_contains?: string | null
  meaning_starts_with?: string | null
  meaning_not_starts_with?: string | null
  meaning_ends_with?: string | null
  meaning_not_ends_with?: string | null
  AND?: StrengthWhereInput[]
  OR?: StrengthWhereInput[]
  NOT?: StrengthWhereInput[]
}
export type StrengthWhereInputInputObject =
  | Extract<keyof StrengthWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'strength', alias?: string  } 
  | { name: 'strength_not', alias?: string  } 
  | { name: 'strength_in', alias?: string  } 
  | { name: 'strength_not_in', alias?: string  } 
  | { name: 'strength_lt', alias?: string  } 
  | { name: 'strength_lte', alias?: string  } 
  | { name: 'strength_gt', alias?: string  } 
  | { name: 'strength_gte', alias?: string  } 
  | { name: 'meaning', alias?: string  } 
  | { name: 'meaning_not', alias?: string  } 
  | { name: 'meaning_in', alias?: string  } 
  | { name: 'meaning_not_in', alias?: string  } 
  | { name: 'meaning_lt', alias?: string  } 
  | { name: 'meaning_lte', alias?: string  } 
  | { name: 'meaning_gt', alias?: string  } 
  | { name: 'meaning_gte', alias?: string  } 
  | { name: 'meaning_contains', alias?: string  } 
  | { name: 'meaning_not_contains', alias?: string  } 
  | { name: 'meaning_starts_with', alias?: string  } 
  | { name: 'meaning_not_starts_with', alias?: string  } 
  | { name: 'meaning_ends_with', alias?: string  } 
  | { name: 'meaning_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CategoryWhereUniqueInput {
  id?: string | null
}
export type CategoryWhereUniqueInputInputObject =
  | Extract<keyof CategoryWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface KeywordWhereUniqueInput {
  id?: string | null
}
export type KeywordWhereUniqueInputInputObject =
  | Extract<keyof KeywordWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface ScenarioWhereUniqueInput {
  id?: string | null
}
export type ScenarioWhereUniqueInputInputObject =
  | Extract<keyof ScenarioWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface IndicatorWhereUniqueInput {
  id?: string | null
}
export type IndicatorWhereUniqueInputInputObject =
  | Extract<keyof IndicatorWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface IndicationWhereUniqueInput {
  id?: string | null
}
export type IndicationWhereUniqueInputInputObject =
  | Extract<keyof IndicationWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface StrengthWhereUniqueInput {
  id?: string | null
}
export type StrengthWhereUniqueInputInputObject =
  | Extract<keyof StrengthWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface UserCreateInput {
  name?: string
}
export type UserCreateInputInputObject =
  | Extract<keyof UserCreateInput, string>
  | { name: 'name', alias?: string  } 
  
export interface UserUpdateInput {
  name?: string | null
}
export type UserUpdateInputInputObject =
  | Extract<keyof UserUpdateInput, string>
  | { name: 'name', alias?: string  } 
  
export interface UserUpdateManyMutationInput {
  name?: string | null
}
export type UserUpdateManyMutationInputInputObject =
  | Extract<keyof UserUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  
export interface EventCreateInput {
  date?: string | null
  title?: string | null
  description?: string | null
  href?: string | null
  source?: string | null
  read?: boolean | null
  indications?: IndicationCreateManyWithoutEventInput | null
  categories?: CategoryCreateManyWithoutEventsInput | null
}
export type EventCreateInputInputObject =
  | Extract<keyof EventCreateInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'read', alias?: string  } 
  | { name: 'indications', alias?: string  } 
  | { name: 'categories', alias?: string  } 
  
export interface IndicationCreateManyWithoutEventInput {
  create?: IndicationCreateWithoutEventInput[]
  connect?: IndicationWhereUniqueInput[]
}
export type IndicationCreateManyWithoutEventInputInputObject =
  | Extract<keyof IndicationCreateManyWithoutEventInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface IndicationCreateWithoutEventInput {
  indicator?: IndicatorCreateOneInput
  strength?: StrengthCreateOneInput
}
export type IndicationCreateWithoutEventInputInputObject =
  | Extract<keyof IndicationCreateWithoutEventInput, string>
  | { name: 'indicator', alias?: string  } 
  | { name: 'strength', alias?: string  } 
  
export interface IndicatorCreateOneInput {
  create?: IndicatorCreateInput | null
  connect?: IndicatorWhereUniqueInput | null
}
export type IndicatorCreateOneInputInputObject =
  | Extract<keyof IndicatorCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface IndicatorCreateInput {
  name?: string | null
  description?: string | null
  keywords?: KeywordCreateManyWithoutIndicatorsInput | null
  scenarios?: ScenarioCreateManyWithoutIndicatorsInput | null
}
export type IndicatorCreateInputInputObject =
  | Extract<keyof IndicatorCreateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'keywords', alias?: string  } 
  | { name: 'scenarios', alias?: string  } 
  
export interface KeywordCreateManyWithoutIndicatorsInput {
  create?: KeywordCreateWithoutIndicatorsInput[]
  connect?: KeywordWhereUniqueInput[]
}
export type KeywordCreateManyWithoutIndicatorsInputInputObject =
  | Extract<keyof KeywordCreateManyWithoutIndicatorsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface KeywordCreateWithoutIndicatorsInput {
  name?: string | null
  description?: string | null
}
export type KeywordCreateWithoutIndicatorsInputInputObject =
  | Extract<keyof KeywordCreateWithoutIndicatorsInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface ScenarioCreateManyWithoutIndicatorsInput {
  create?: ScenarioCreateWithoutIndicatorsInput[]
  connect?: ScenarioWhereUniqueInput[]
}
export type ScenarioCreateManyWithoutIndicatorsInputInputObject =
  | Extract<keyof ScenarioCreateManyWithoutIndicatorsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface ScenarioCreateWithoutIndicatorsInput {
  name?: string | null
  description?: string | null
}
export type ScenarioCreateWithoutIndicatorsInputInputObject =
  | Extract<keyof ScenarioCreateWithoutIndicatorsInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface StrengthCreateOneInput {
  create?: StrengthCreateInput | null
  connect?: StrengthWhereUniqueInput | null
}
export type StrengthCreateOneInputInputObject =
  | Extract<keyof StrengthCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface StrengthCreateInput {
  strength?: number | null
  meaning?: string | null
}
export type StrengthCreateInputInputObject =
  | Extract<keyof StrengthCreateInput, string>
  | { name: 'strength', alias?: string  } 
  | { name: 'meaning', alias?: string  } 
  
export interface CategoryCreateManyWithoutEventsInput {
  create?: CategoryCreateWithoutEventsInput[]
  connect?: CategoryWhereUniqueInput[]
}
export type CategoryCreateManyWithoutEventsInputInputObject =
  | Extract<keyof CategoryCreateManyWithoutEventsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface CategoryCreateWithoutEventsInput {
  name?: string
}
export type CategoryCreateWithoutEventsInputInputObject =
  | Extract<keyof CategoryCreateWithoutEventsInput, string>
  | { name: 'name', alias?: string  } 
  
export interface EventUpdateInput {
  date?: string | null
  title?: string | null
  description?: string | null
  href?: string | null
  source?: string | null
  read?: boolean | null
  indications?: IndicationUpdateManyWithoutEventInput | null
  categories?: CategoryUpdateManyWithoutEventsInput | null
}
export type EventUpdateInputInputObject =
  | Extract<keyof EventUpdateInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'read', alias?: string  } 
  | { name: 'indications', alias?: string  } 
  | { name: 'categories', alias?: string  } 
  
export interface IndicationUpdateManyWithoutEventInput {
  create?: IndicationCreateWithoutEventInput[]
  delete?: IndicationWhereUniqueInput[]
  connect?: IndicationWhereUniqueInput[]
  set?: IndicationWhereUniqueInput[]
  disconnect?: IndicationWhereUniqueInput[]
  update?: IndicationUpdateWithWhereUniqueWithoutEventInput[]
  upsert?: IndicationUpsertWithWhereUniqueWithoutEventInput[]
  deleteMany?: IndicationScalarWhereInput[]
}
export type IndicationUpdateManyWithoutEventInputInputObject =
  | Extract<keyof IndicationUpdateManyWithoutEventInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  
export interface IndicationUpdateWithWhereUniqueWithoutEventInput {
  where?: IndicationWhereUniqueInput
  data?: IndicationUpdateWithoutEventDataInput
}
export type IndicationUpdateWithWhereUniqueWithoutEventInputInputObject =
  | Extract<keyof IndicationUpdateWithWhereUniqueWithoutEventInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface IndicationUpdateWithoutEventDataInput {
  indicator?: IndicatorUpdateOneRequiredInput | null
  strength?: StrengthUpdateOneRequiredInput | null
}
export type IndicationUpdateWithoutEventDataInputInputObject =
  | Extract<keyof IndicationUpdateWithoutEventDataInput, string>
  | { name: 'indicator', alias?: string  } 
  | { name: 'strength', alias?: string  } 
  
export interface IndicatorUpdateOneRequiredInput {
  create?: IndicatorCreateInput | null
  update?: IndicatorUpdateDataInput | null
  upsert?: IndicatorUpsertNestedInput | null
  connect?: IndicatorWhereUniqueInput | null
}
export type IndicatorUpdateOneRequiredInputInputObject =
  | Extract<keyof IndicatorUpdateOneRequiredInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface IndicatorUpdateDataInput {
  name?: string | null
  description?: string | null
  keywords?: KeywordUpdateManyWithoutIndicatorsInput | null
  scenarios?: ScenarioUpdateManyWithoutIndicatorsInput | null
}
export type IndicatorUpdateDataInputInputObject =
  | Extract<keyof IndicatorUpdateDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'keywords', alias?: string  } 
  | { name: 'scenarios', alias?: string  } 
  
export interface KeywordUpdateManyWithoutIndicatorsInput {
  create?: KeywordCreateWithoutIndicatorsInput[]
  delete?: KeywordWhereUniqueInput[]
  connect?: KeywordWhereUniqueInput[]
  set?: KeywordWhereUniqueInput[]
  disconnect?: KeywordWhereUniqueInput[]
  update?: KeywordUpdateWithWhereUniqueWithoutIndicatorsInput[]
  upsert?: KeywordUpsertWithWhereUniqueWithoutIndicatorsInput[]
  deleteMany?: KeywordScalarWhereInput[]
  updateMany?: KeywordUpdateManyWithWhereNestedInput[]
}
export type KeywordUpdateManyWithoutIndicatorsInputInputObject =
  | Extract<keyof KeywordUpdateManyWithoutIndicatorsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface KeywordUpdateWithWhereUniqueWithoutIndicatorsInput {
  where?: KeywordWhereUniqueInput
  data?: KeywordUpdateWithoutIndicatorsDataInput
}
export type KeywordUpdateWithWhereUniqueWithoutIndicatorsInputInputObject =
  | Extract<keyof KeywordUpdateWithWhereUniqueWithoutIndicatorsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface KeywordUpdateWithoutIndicatorsDataInput {
  name?: string | null
  description?: string | null
}
export type KeywordUpdateWithoutIndicatorsDataInputInputObject =
  | Extract<keyof KeywordUpdateWithoutIndicatorsDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface KeywordUpsertWithWhereUniqueWithoutIndicatorsInput {
  where?: KeywordWhereUniqueInput
  update?: KeywordUpdateWithoutIndicatorsDataInput
  create?: KeywordCreateWithoutIndicatorsInput
}
export type KeywordUpsertWithWhereUniqueWithoutIndicatorsInputInputObject =
  | Extract<keyof KeywordUpsertWithWhereUniqueWithoutIndicatorsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface KeywordScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  AND?: KeywordScalarWhereInput[]
  OR?: KeywordScalarWhereInput[]
  NOT?: KeywordScalarWhereInput[]
}
export type KeywordScalarWhereInputInputObject =
  | Extract<keyof KeywordScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface KeywordUpdateManyWithWhereNestedInput {
  where?: KeywordScalarWhereInput
  data?: KeywordUpdateManyDataInput
}
export type KeywordUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof KeywordUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface KeywordUpdateManyDataInput {
  name?: string | null
  description?: string | null
}
export type KeywordUpdateManyDataInputInputObject =
  | Extract<keyof KeywordUpdateManyDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface ScenarioUpdateManyWithoutIndicatorsInput {
  create?: ScenarioCreateWithoutIndicatorsInput[]
  delete?: ScenarioWhereUniqueInput[]
  connect?: ScenarioWhereUniqueInput[]
  set?: ScenarioWhereUniqueInput[]
  disconnect?: ScenarioWhereUniqueInput[]
  update?: ScenarioUpdateWithWhereUniqueWithoutIndicatorsInput[]
  upsert?: ScenarioUpsertWithWhereUniqueWithoutIndicatorsInput[]
  deleteMany?: ScenarioScalarWhereInput[]
  updateMany?: ScenarioUpdateManyWithWhereNestedInput[]
}
export type ScenarioUpdateManyWithoutIndicatorsInputInputObject =
  | Extract<keyof ScenarioUpdateManyWithoutIndicatorsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface ScenarioUpdateWithWhereUniqueWithoutIndicatorsInput {
  where?: ScenarioWhereUniqueInput
  data?: ScenarioUpdateWithoutIndicatorsDataInput
}
export type ScenarioUpdateWithWhereUniqueWithoutIndicatorsInputInputObject =
  | Extract<keyof ScenarioUpdateWithWhereUniqueWithoutIndicatorsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface ScenarioUpdateWithoutIndicatorsDataInput {
  name?: string | null
  description?: string | null
}
export type ScenarioUpdateWithoutIndicatorsDataInputInputObject =
  | Extract<keyof ScenarioUpdateWithoutIndicatorsDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface ScenarioUpsertWithWhereUniqueWithoutIndicatorsInput {
  where?: ScenarioWhereUniqueInput
  update?: ScenarioUpdateWithoutIndicatorsDataInput
  create?: ScenarioCreateWithoutIndicatorsInput
}
export type ScenarioUpsertWithWhereUniqueWithoutIndicatorsInputInputObject =
  | Extract<keyof ScenarioUpsertWithWhereUniqueWithoutIndicatorsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface ScenarioScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  AND?: ScenarioScalarWhereInput[]
  OR?: ScenarioScalarWhereInput[]
  NOT?: ScenarioScalarWhereInput[]
}
export type ScenarioScalarWhereInputInputObject =
  | Extract<keyof ScenarioScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface ScenarioUpdateManyWithWhereNestedInput {
  where?: ScenarioScalarWhereInput
  data?: ScenarioUpdateManyDataInput
}
export type ScenarioUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof ScenarioUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface ScenarioUpdateManyDataInput {
  name?: string | null
  description?: string | null
}
export type ScenarioUpdateManyDataInputInputObject =
  | Extract<keyof ScenarioUpdateManyDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface IndicatorUpsertNestedInput {
  update?: IndicatorUpdateDataInput
  create?: IndicatorCreateInput
}
export type IndicatorUpsertNestedInputInputObject =
  | Extract<keyof IndicatorUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface StrengthUpdateOneRequiredInput {
  create?: StrengthCreateInput | null
  update?: StrengthUpdateDataInput | null
  upsert?: StrengthUpsertNestedInput | null
  connect?: StrengthWhereUniqueInput | null
}
export type StrengthUpdateOneRequiredInputInputObject =
  | Extract<keyof StrengthUpdateOneRequiredInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface StrengthUpdateDataInput {
  strength?: number | null
  meaning?: string | null
}
export type StrengthUpdateDataInputInputObject =
  | Extract<keyof StrengthUpdateDataInput, string>
  | { name: 'strength', alias?: string  } 
  | { name: 'meaning', alias?: string  } 
  
export interface StrengthUpsertNestedInput {
  update?: StrengthUpdateDataInput
  create?: StrengthCreateInput
}
export type StrengthUpsertNestedInputInputObject =
  | Extract<keyof StrengthUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface IndicationUpsertWithWhereUniqueWithoutEventInput {
  where?: IndicationWhereUniqueInput
  update?: IndicationUpdateWithoutEventDataInput
  create?: IndicationCreateWithoutEventInput
}
export type IndicationUpsertWithWhereUniqueWithoutEventInputInputObject =
  | Extract<keyof IndicationUpsertWithWhereUniqueWithoutEventInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface IndicationScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  createdAt?: string | null
  createdAt_not?: string | null
  createdAt_in?: string[]
  createdAt_not_in?: string[]
  createdAt_lt?: string | null
  createdAt_lte?: string | null
  createdAt_gt?: string | null
  createdAt_gte?: string | null
  updatedAt?: string | null
  updatedAt_not?: string | null
  updatedAt_in?: string[]
  updatedAt_not_in?: string[]
  updatedAt_lt?: string | null
  updatedAt_lte?: string | null
  updatedAt_gt?: string | null
  updatedAt_gte?: string | null
  AND?: IndicationScalarWhereInput[]
  OR?: IndicationScalarWhereInput[]
  NOT?: IndicationScalarWhereInput[]
}
export type IndicationScalarWhereInputInputObject =
  | Extract<keyof IndicationScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'createdAt', alias?: string  } 
  | { name: 'createdAt_not', alias?: string  } 
  | { name: 'createdAt_in', alias?: string  } 
  | { name: 'createdAt_not_in', alias?: string  } 
  | { name: 'createdAt_lt', alias?: string  } 
  | { name: 'createdAt_lte', alias?: string  } 
  | { name: 'createdAt_gt', alias?: string  } 
  | { name: 'createdAt_gte', alias?: string  } 
  | { name: 'updatedAt', alias?: string  } 
  | { name: 'updatedAt_not', alias?: string  } 
  | { name: 'updatedAt_in', alias?: string  } 
  | { name: 'updatedAt_not_in', alias?: string  } 
  | { name: 'updatedAt_lt', alias?: string  } 
  | { name: 'updatedAt_lte', alias?: string  } 
  | { name: 'updatedAt_gt', alias?: string  } 
  | { name: 'updatedAt_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CategoryUpdateManyWithoutEventsInput {
  create?: CategoryCreateWithoutEventsInput[]
  delete?: CategoryWhereUniqueInput[]
  connect?: CategoryWhereUniqueInput[]
  set?: CategoryWhereUniqueInput[]
  disconnect?: CategoryWhereUniqueInput[]
  update?: CategoryUpdateWithWhereUniqueWithoutEventsInput[]
  upsert?: CategoryUpsertWithWhereUniqueWithoutEventsInput[]
  deleteMany?: CategoryScalarWhereInput[]
  updateMany?: CategoryUpdateManyWithWhereNestedInput[]
}
export type CategoryUpdateManyWithoutEventsInputInputObject =
  | Extract<keyof CategoryUpdateManyWithoutEventsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface CategoryUpdateWithWhereUniqueWithoutEventsInput {
  where?: CategoryWhereUniqueInput
  data?: CategoryUpdateWithoutEventsDataInput
}
export type CategoryUpdateWithWhereUniqueWithoutEventsInputInputObject =
  | Extract<keyof CategoryUpdateWithWhereUniqueWithoutEventsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface CategoryUpdateWithoutEventsDataInput {
  name?: string | null
}
export type CategoryUpdateWithoutEventsDataInputInputObject =
  | Extract<keyof CategoryUpdateWithoutEventsDataInput, string>
  | { name: 'name', alias?: string  } 
  
export interface CategoryUpsertWithWhereUniqueWithoutEventsInput {
  where?: CategoryWhereUniqueInput
  update?: CategoryUpdateWithoutEventsDataInput
  create?: CategoryCreateWithoutEventsInput
}
export type CategoryUpsertWithWhereUniqueWithoutEventsInputInputObject =
  | Extract<keyof CategoryUpsertWithWhereUniqueWithoutEventsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CategoryScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  AND?: CategoryScalarWhereInput[]
  OR?: CategoryScalarWhereInput[]
  NOT?: CategoryScalarWhereInput[]
}
export type CategoryScalarWhereInputInputObject =
  | Extract<keyof CategoryScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CategoryUpdateManyWithWhereNestedInput {
  where?: CategoryScalarWhereInput
  data?: CategoryUpdateManyDataInput
}
export type CategoryUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof CategoryUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface CategoryUpdateManyDataInput {
  name?: string | null
}
export type CategoryUpdateManyDataInputInputObject =
  | Extract<keyof CategoryUpdateManyDataInput, string>
  | { name: 'name', alias?: string  } 
  
export interface EventUpdateManyMutationInput {
  date?: string | null
  title?: string | null
  description?: string | null
  href?: string | null
  source?: string | null
  read?: boolean | null
}
export type EventUpdateManyMutationInputInputObject =
  | Extract<keyof EventUpdateManyMutationInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'read', alias?: string  } 
  
export interface CategoryCreateInput {
  name?: string
  events?: EventCreateManyWithoutCategoriesInput | null
}
export type CategoryCreateInputInputObject =
  | Extract<keyof CategoryCreateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'events', alias?: string  } 
  
export interface EventCreateManyWithoutCategoriesInput {
  create?: EventCreateWithoutCategoriesInput[]
  connect?: EventWhereUniqueInput[]
}
export type EventCreateManyWithoutCategoriesInputInputObject =
  | Extract<keyof EventCreateManyWithoutCategoriesInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface EventCreateWithoutCategoriesInput {
  date?: string | null
  title?: string | null
  description?: string | null
  href?: string | null
  source?: string | null
  read?: boolean | null
  indications?: IndicationCreateManyWithoutEventInput | null
}
export type EventCreateWithoutCategoriesInputInputObject =
  | Extract<keyof EventCreateWithoutCategoriesInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'read', alias?: string  } 
  | { name: 'indications', alias?: string  } 
  
export interface CategoryUpdateInput {
  name?: string | null
  events?: EventUpdateManyWithoutCategoriesInput | null
}
export type CategoryUpdateInputInputObject =
  | Extract<keyof CategoryUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'events', alias?: string  } 
  
export interface EventUpdateManyWithoutCategoriesInput {
  create?: EventCreateWithoutCategoriesInput[]
  delete?: EventWhereUniqueInput[]
  connect?: EventWhereUniqueInput[]
  set?: EventWhereUniqueInput[]
  disconnect?: EventWhereUniqueInput[]
  update?: EventUpdateWithWhereUniqueWithoutCategoriesInput[]
  upsert?: EventUpsertWithWhereUniqueWithoutCategoriesInput[]
  deleteMany?: EventScalarWhereInput[]
  updateMany?: EventUpdateManyWithWhereNestedInput[]
}
export type EventUpdateManyWithoutCategoriesInputInputObject =
  | Extract<keyof EventUpdateManyWithoutCategoriesInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface EventUpdateWithWhereUniqueWithoutCategoriesInput {
  where?: EventWhereUniqueInput
  data?: EventUpdateWithoutCategoriesDataInput
}
export type EventUpdateWithWhereUniqueWithoutCategoriesInputInputObject =
  | Extract<keyof EventUpdateWithWhereUniqueWithoutCategoriesInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface EventUpdateWithoutCategoriesDataInput {
  date?: string | null
  title?: string | null
  description?: string | null
  href?: string | null
  source?: string | null
  read?: boolean | null
  indications?: IndicationUpdateManyWithoutEventInput | null
}
export type EventUpdateWithoutCategoriesDataInputInputObject =
  | Extract<keyof EventUpdateWithoutCategoriesDataInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'read', alias?: string  } 
  | { name: 'indications', alias?: string  } 
  
export interface EventUpsertWithWhereUniqueWithoutCategoriesInput {
  where?: EventWhereUniqueInput
  update?: EventUpdateWithoutCategoriesDataInput
  create?: EventCreateWithoutCategoriesInput
}
export type EventUpsertWithWhereUniqueWithoutCategoriesInputInputObject =
  | Extract<keyof EventUpsertWithWhereUniqueWithoutCategoriesInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface EventScalarWhereInput {
  date?: string | null
  date_not?: string | null
  date_in?: string[]
  date_not_in?: string[]
  date_lt?: string | null
  date_lte?: string | null
  date_gt?: string | null
  date_gte?: string | null
  title?: string | null
  title_not?: string | null
  title_in?: string[]
  title_not_in?: string[]
  title_lt?: string | null
  title_lte?: string | null
  title_gt?: string | null
  title_gte?: string | null
  title_contains?: string | null
  title_not_contains?: string | null
  title_starts_with?: string | null
  title_not_starts_with?: string | null
  title_ends_with?: string | null
  title_not_ends_with?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  href?: string | null
  href_not?: string | null
  href_in?: string[]
  href_not_in?: string[]
  href_lt?: string | null
  href_lte?: string | null
  href_gt?: string | null
  href_gte?: string | null
  href_contains?: string | null
  href_not_contains?: string | null
  href_starts_with?: string | null
  href_not_starts_with?: string | null
  href_ends_with?: string | null
  href_not_ends_with?: string | null
  source?: string | null
  source_not?: string | null
  source_in?: string[]
  source_not_in?: string[]
  source_lt?: string | null
  source_lte?: string | null
  source_gt?: string | null
  source_gte?: string | null
  source_contains?: string | null
  source_not_contains?: string | null
  source_starts_with?: string | null
  source_not_starts_with?: string | null
  source_ends_with?: string | null
  source_not_ends_with?: string | null
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  read?: boolean | null
  read_not?: boolean | null
  AND?: EventScalarWhereInput[]
  OR?: EventScalarWhereInput[]
  NOT?: EventScalarWhereInput[]
}
export type EventScalarWhereInputInputObject =
  | Extract<keyof EventScalarWhereInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'date_not', alias?: string  } 
  | { name: 'date_in', alias?: string  } 
  | { name: 'date_not_in', alias?: string  } 
  | { name: 'date_lt', alias?: string  } 
  | { name: 'date_lte', alias?: string  } 
  | { name: 'date_gt', alias?: string  } 
  | { name: 'date_gte', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'title_not', alias?: string  } 
  | { name: 'title_in', alias?: string  } 
  | { name: 'title_not_in', alias?: string  } 
  | { name: 'title_lt', alias?: string  } 
  | { name: 'title_lte', alias?: string  } 
  | { name: 'title_gt', alias?: string  } 
  | { name: 'title_gte', alias?: string  } 
  | { name: 'title_contains', alias?: string  } 
  | { name: 'title_not_contains', alias?: string  } 
  | { name: 'title_starts_with', alias?: string  } 
  | { name: 'title_not_starts_with', alias?: string  } 
  | { name: 'title_ends_with', alias?: string  } 
  | { name: 'title_not_ends_with', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'href_not', alias?: string  } 
  | { name: 'href_in', alias?: string  } 
  | { name: 'href_not_in', alias?: string  } 
  | { name: 'href_lt', alias?: string  } 
  | { name: 'href_lte', alias?: string  } 
  | { name: 'href_gt', alias?: string  } 
  | { name: 'href_gte', alias?: string  } 
  | { name: 'href_contains', alias?: string  } 
  | { name: 'href_not_contains', alias?: string  } 
  | { name: 'href_starts_with', alias?: string  } 
  | { name: 'href_not_starts_with', alias?: string  } 
  | { name: 'href_ends_with', alias?: string  } 
  | { name: 'href_not_ends_with', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'source_not', alias?: string  } 
  | { name: 'source_in', alias?: string  } 
  | { name: 'source_not_in', alias?: string  } 
  | { name: 'source_lt', alias?: string  } 
  | { name: 'source_lte', alias?: string  } 
  | { name: 'source_gt', alias?: string  } 
  | { name: 'source_gte', alias?: string  } 
  | { name: 'source_contains', alias?: string  } 
  | { name: 'source_not_contains', alias?: string  } 
  | { name: 'source_starts_with', alias?: string  } 
  | { name: 'source_not_starts_with', alias?: string  } 
  | { name: 'source_ends_with', alias?: string  } 
  | { name: 'source_not_ends_with', alias?: string  } 
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'read', alias?: string  } 
  | { name: 'read_not', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface EventUpdateManyWithWhereNestedInput {
  where?: EventScalarWhereInput
  data?: EventUpdateManyDataInput
}
export type EventUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof EventUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface EventUpdateManyDataInput {
  date?: string | null
  title?: string | null
  description?: string | null
  href?: string | null
  source?: string | null
  read?: boolean | null
}
export type EventUpdateManyDataInputInputObject =
  | Extract<keyof EventUpdateManyDataInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'read', alias?: string  } 
  
export interface CategoryUpdateManyMutationInput {
  name?: string | null
}
export type CategoryUpdateManyMutationInputInputObject =
  | Extract<keyof CategoryUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  
export interface KeywordCreateInput {
  name?: string | null
  description?: string | null
  indicators?: IndicatorCreateManyWithoutKeywordsInput | null
}
export type KeywordCreateInputInputObject =
  | Extract<keyof KeywordCreateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'indicators', alias?: string  } 
  
export interface IndicatorCreateManyWithoutKeywordsInput {
  create?: IndicatorCreateWithoutKeywordsInput[]
  connect?: IndicatorWhereUniqueInput[]
}
export type IndicatorCreateManyWithoutKeywordsInputInputObject =
  | Extract<keyof IndicatorCreateManyWithoutKeywordsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface IndicatorCreateWithoutKeywordsInput {
  name?: string | null
  description?: string | null
  scenarios?: ScenarioCreateManyWithoutIndicatorsInput | null
}
export type IndicatorCreateWithoutKeywordsInputInputObject =
  | Extract<keyof IndicatorCreateWithoutKeywordsInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'scenarios', alias?: string  } 
  
export interface KeywordUpdateInput {
  name?: string | null
  description?: string | null
  indicators?: IndicatorUpdateManyWithoutKeywordsInput | null
}
export type KeywordUpdateInputInputObject =
  | Extract<keyof KeywordUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'indicators', alias?: string  } 
  
export interface IndicatorUpdateManyWithoutKeywordsInput {
  create?: IndicatorCreateWithoutKeywordsInput[]
  delete?: IndicatorWhereUniqueInput[]
  connect?: IndicatorWhereUniqueInput[]
  set?: IndicatorWhereUniqueInput[]
  disconnect?: IndicatorWhereUniqueInput[]
  update?: IndicatorUpdateWithWhereUniqueWithoutKeywordsInput[]
  upsert?: IndicatorUpsertWithWhereUniqueWithoutKeywordsInput[]
  deleteMany?: IndicatorScalarWhereInput[]
  updateMany?: IndicatorUpdateManyWithWhereNestedInput[]
}
export type IndicatorUpdateManyWithoutKeywordsInputInputObject =
  | Extract<keyof IndicatorUpdateManyWithoutKeywordsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface IndicatorUpdateWithWhereUniqueWithoutKeywordsInput {
  where?: IndicatorWhereUniqueInput
  data?: IndicatorUpdateWithoutKeywordsDataInput
}
export type IndicatorUpdateWithWhereUniqueWithoutKeywordsInputInputObject =
  | Extract<keyof IndicatorUpdateWithWhereUniqueWithoutKeywordsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface IndicatorUpdateWithoutKeywordsDataInput {
  name?: string | null
  description?: string | null
  scenarios?: ScenarioUpdateManyWithoutIndicatorsInput | null
}
export type IndicatorUpdateWithoutKeywordsDataInputInputObject =
  | Extract<keyof IndicatorUpdateWithoutKeywordsDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'scenarios', alias?: string  } 
  
export interface IndicatorUpsertWithWhereUniqueWithoutKeywordsInput {
  where?: IndicatorWhereUniqueInput
  update?: IndicatorUpdateWithoutKeywordsDataInput
  create?: IndicatorCreateWithoutKeywordsInput
}
export type IndicatorUpsertWithWhereUniqueWithoutKeywordsInputInputObject =
  | Extract<keyof IndicatorUpsertWithWhereUniqueWithoutKeywordsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface IndicatorScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  AND?: IndicatorScalarWhereInput[]
  OR?: IndicatorScalarWhereInput[]
  NOT?: IndicatorScalarWhereInput[]
}
export type IndicatorScalarWhereInputInputObject =
  | Extract<keyof IndicatorScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface IndicatorUpdateManyWithWhereNestedInput {
  where?: IndicatorScalarWhereInput
  data?: IndicatorUpdateManyDataInput
}
export type IndicatorUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof IndicatorUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface IndicatorUpdateManyDataInput {
  name?: string | null
  description?: string | null
}
export type IndicatorUpdateManyDataInputInputObject =
  | Extract<keyof IndicatorUpdateManyDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface KeywordUpdateManyMutationInput {
  name?: string | null
  description?: string | null
}
export type KeywordUpdateManyMutationInputInputObject =
  | Extract<keyof KeywordUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface ScenarioCreateInput {
  name?: string | null
  description?: string | null
  indicators?: IndicatorCreateManyWithoutScenariosInput | null
}
export type ScenarioCreateInputInputObject =
  | Extract<keyof ScenarioCreateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'indicators', alias?: string  } 
  
export interface IndicatorCreateManyWithoutScenariosInput {
  create?: IndicatorCreateWithoutScenariosInput[]
  connect?: IndicatorWhereUniqueInput[]
}
export type IndicatorCreateManyWithoutScenariosInputInputObject =
  | Extract<keyof IndicatorCreateManyWithoutScenariosInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface IndicatorCreateWithoutScenariosInput {
  name?: string | null
  description?: string | null
  keywords?: KeywordCreateManyWithoutIndicatorsInput | null
}
export type IndicatorCreateWithoutScenariosInputInputObject =
  | Extract<keyof IndicatorCreateWithoutScenariosInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'keywords', alias?: string  } 
  
export interface ScenarioUpdateInput {
  name?: string | null
  description?: string | null
  indicators?: IndicatorUpdateManyWithoutScenariosInput | null
}
export type ScenarioUpdateInputInputObject =
  | Extract<keyof ScenarioUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'indicators', alias?: string  } 
  
export interface IndicatorUpdateManyWithoutScenariosInput {
  create?: IndicatorCreateWithoutScenariosInput[]
  delete?: IndicatorWhereUniqueInput[]
  connect?: IndicatorWhereUniqueInput[]
  set?: IndicatorWhereUniqueInput[]
  disconnect?: IndicatorWhereUniqueInput[]
  update?: IndicatorUpdateWithWhereUniqueWithoutScenariosInput[]
  upsert?: IndicatorUpsertWithWhereUniqueWithoutScenariosInput[]
  deleteMany?: IndicatorScalarWhereInput[]
  updateMany?: IndicatorUpdateManyWithWhereNestedInput[]
}
export type IndicatorUpdateManyWithoutScenariosInputInputObject =
  | Extract<keyof IndicatorUpdateManyWithoutScenariosInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface IndicatorUpdateWithWhereUniqueWithoutScenariosInput {
  where?: IndicatorWhereUniqueInput
  data?: IndicatorUpdateWithoutScenariosDataInput
}
export type IndicatorUpdateWithWhereUniqueWithoutScenariosInputInputObject =
  | Extract<keyof IndicatorUpdateWithWhereUniqueWithoutScenariosInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface IndicatorUpdateWithoutScenariosDataInput {
  name?: string | null
  description?: string | null
  keywords?: KeywordUpdateManyWithoutIndicatorsInput | null
}
export type IndicatorUpdateWithoutScenariosDataInputInputObject =
  | Extract<keyof IndicatorUpdateWithoutScenariosDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'keywords', alias?: string  } 
  
export interface IndicatorUpsertWithWhereUniqueWithoutScenariosInput {
  where?: IndicatorWhereUniqueInput
  update?: IndicatorUpdateWithoutScenariosDataInput
  create?: IndicatorCreateWithoutScenariosInput
}
export type IndicatorUpsertWithWhereUniqueWithoutScenariosInputInputObject =
  | Extract<keyof IndicatorUpsertWithWhereUniqueWithoutScenariosInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface ScenarioUpdateManyMutationInput {
  name?: string | null
  description?: string | null
}
export type ScenarioUpdateManyMutationInputInputObject =
  | Extract<keyof ScenarioUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface IndicatorUpdateInput {
  name?: string | null
  description?: string | null
  keywords?: KeywordUpdateManyWithoutIndicatorsInput | null
  scenarios?: ScenarioUpdateManyWithoutIndicatorsInput | null
}
export type IndicatorUpdateInputInputObject =
  | Extract<keyof IndicatorUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'keywords', alias?: string  } 
  | { name: 'scenarios', alias?: string  } 
  
export interface IndicatorUpdateManyMutationInput {
  name?: string | null
  description?: string | null
}
export type IndicatorUpdateManyMutationInputInputObject =
  | Extract<keyof IndicatorUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface IndicationCreateInput {
  indicator?: IndicatorCreateOneInput
  event?: EventCreateOneWithoutIndicationsInput
  strength?: StrengthCreateOneInput
}
export type IndicationCreateInputInputObject =
  | Extract<keyof IndicationCreateInput, string>
  | { name: 'indicator', alias?: string  } 
  | { name: 'event', alias?: string  } 
  | { name: 'strength', alias?: string  } 
  
export interface EventCreateOneWithoutIndicationsInput {
  create?: EventCreateWithoutIndicationsInput | null
  connect?: EventWhereUniqueInput | null
}
export type EventCreateOneWithoutIndicationsInputInputObject =
  | Extract<keyof EventCreateOneWithoutIndicationsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface EventCreateWithoutIndicationsInput {
  date?: string | null
  title?: string | null
  description?: string | null
  href?: string | null
  source?: string | null
  read?: boolean | null
  categories?: CategoryCreateManyWithoutEventsInput | null
}
export type EventCreateWithoutIndicationsInputInputObject =
  | Extract<keyof EventCreateWithoutIndicationsInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'read', alias?: string  } 
  | { name: 'categories', alias?: string  } 
  
export interface IndicationUpdateInput {
  indicator?: IndicatorUpdateOneRequiredInput | null
  event?: EventUpdateOneRequiredWithoutIndicationsInput | null
  strength?: StrengthUpdateOneRequiredInput | null
}
export type IndicationUpdateInputInputObject =
  | Extract<keyof IndicationUpdateInput, string>
  | { name: 'indicator', alias?: string  } 
  | { name: 'event', alias?: string  } 
  | { name: 'strength', alias?: string  } 
  
export interface EventUpdateOneRequiredWithoutIndicationsInput {
  create?: EventCreateWithoutIndicationsInput | null
  update?: EventUpdateWithoutIndicationsDataInput | null
  upsert?: EventUpsertWithoutIndicationsInput | null
  connect?: EventWhereUniqueInput | null
}
export type EventUpdateOneRequiredWithoutIndicationsInputInputObject =
  | Extract<keyof EventUpdateOneRequiredWithoutIndicationsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface EventUpdateWithoutIndicationsDataInput {
  date?: string | null
  title?: string | null
  description?: string | null
  href?: string | null
  source?: string | null
  read?: boolean | null
  categories?: CategoryUpdateManyWithoutEventsInput | null
}
export type EventUpdateWithoutIndicationsDataInputInputObject =
  | Extract<keyof EventUpdateWithoutIndicationsDataInput, string>
  | { name: 'date', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'href', alias?: string  } 
  | { name: 'source', alias?: string  } 
  | { name: 'read', alias?: string  } 
  | { name: 'categories', alias?: string  } 
  
export interface EventUpsertWithoutIndicationsInput {
  update?: EventUpdateWithoutIndicationsDataInput
  create?: EventCreateWithoutIndicationsInput
}
export type EventUpsertWithoutIndicationsInputInputObject =
  | Extract<keyof EventUpsertWithoutIndicationsInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface StrengthUpdateInput {
  strength?: number | null
  meaning?: string | null
}
export type StrengthUpdateInputInputObject =
  | Extract<keyof StrengthUpdateInput, string>
  | { name: 'strength', alias?: string  } 
  | { name: 'meaning', alias?: string  } 
  
export interface StrengthUpdateManyMutationInput {
  strength?: number | null
  meaning?: string | null
}
export type StrengthUpdateManyMutationInputInputObject =
  | Extract<keyof StrengthUpdateManyMutationInput, string>
  | { name: 'strength', alias?: string  } 
  | { name: 'meaning', alias?: string  } 
  
export interface UserSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: UserWhereInput | null
  AND?: UserSubscriptionWhereInput[]
  OR?: UserSubscriptionWhereInput[]
  NOT?: UserSubscriptionWhereInput[]
}
export type UserSubscriptionWhereInputInputObject =
  | Extract<keyof UserSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface EventSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: EventWhereInput | null
  AND?: EventSubscriptionWhereInput[]
  OR?: EventSubscriptionWhereInput[]
  NOT?: EventSubscriptionWhereInput[]
}
export type EventSubscriptionWhereInputInputObject =
  | Extract<keyof EventSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CategorySubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: CategoryWhereInput | null
  AND?: CategorySubscriptionWhereInput[]
  OR?: CategorySubscriptionWhereInput[]
  NOT?: CategorySubscriptionWhereInput[]
}
export type CategorySubscriptionWhereInputInputObject =
  | Extract<keyof CategorySubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface KeywordSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: KeywordWhereInput | null
  AND?: KeywordSubscriptionWhereInput[]
  OR?: KeywordSubscriptionWhereInput[]
  NOT?: KeywordSubscriptionWhereInput[]
}
export type KeywordSubscriptionWhereInputInputObject =
  | Extract<keyof KeywordSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface ScenarioSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: ScenarioWhereInput | null
  AND?: ScenarioSubscriptionWhereInput[]
  OR?: ScenarioSubscriptionWhereInput[]
  NOT?: ScenarioSubscriptionWhereInput[]
}
export type ScenarioSubscriptionWhereInputInputObject =
  | Extract<keyof ScenarioSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface IndicatorSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: IndicatorWhereInput | null
  AND?: IndicatorSubscriptionWhereInput[]
  OR?: IndicatorSubscriptionWhereInput[]
  NOT?: IndicatorSubscriptionWhereInput[]
}
export type IndicatorSubscriptionWhereInputInputObject =
  | Extract<keyof IndicatorSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface IndicationSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: IndicationWhereInput | null
  AND?: IndicationSubscriptionWhereInput[]
  OR?: IndicationSubscriptionWhereInput[]
  NOT?: IndicationSubscriptionWhereInput[]
}
export type IndicationSubscriptionWhereInputInputObject =
  | Extract<keyof IndicationSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface StrengthSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: StrengthWhereInput | null
  AND?: StrengthSubscriptionWhereInput[]
  OR?: StrengthSubscriptionWhereInput[]
  NOT?: StrengthSubscriptionWhereInput[]
}
export type StrengthSubscriptionWhereInputInputObject =
  | Extract<keyof StrengthSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  

export type UserOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type IndicationOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type KeywordOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type IndicatorOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type ScenarioOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type CategoryOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type EventOrderByInputValues =
  | 'date_ASC'
  | 'date_DESC'
  | 'title_ASC'
  | 'title_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'href_ASC'
  | 'href_DESC'
  | 'source_ASC'
  | 'source_DESC'
  | 'id_ASC'
  | 'id_DESC'
  | 'read_ASC'
  | 'read_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type StrengthOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'strength_ASC'
  | 'strength_DESC'
  | 'meaning_ASC'
  | 'meaning_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type MutationTypeValues =
  | 'CREATED'
  | 'UPDATED'
  | 'DELETED'
  
  